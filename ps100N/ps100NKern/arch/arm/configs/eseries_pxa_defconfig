#
# Automatically generated make config: don't edit
# Linux kernel version: 2.6.28-rc8
# Wed Dec 24 23:35:45 2008
#
CONFIG_ARM=y
CONFIG_SYS_SUPPORTS_APM_EMULATION=y
CONFIG_GENERIC_GPIO=y
CONFIG_GENERIC_TIME=y
CONFIG_GENERIC_CLOCKEVENTS=y
CONFIG_MMU=y
# CONFIG_NO_IOPORT is not set
CONFIG_GENERIC_HARDIRQS=y
CONFIG_STACKTRACE_SUPPORT=y
CONFIG_HAVE_LATENCYTOP_SUPPORT=y
CONFIG_LOCKDEP_SUPPORT=y
CONFIG_TRACE_IRQFLAGS_SUPPORT=y
CONFIG_HARDIRQS_SW_RESEND=y
CONFIG_GENERIC_IRQ_PROBE=y
CONFIG_RWSEM_GENERIC_SPINLOCK=y
# CONFIG_ARCH_HAS_ILOG2_U32 is not set
# CONFIG_ARCH_HAS_ILOG2_U64 is not set
CONFIG_GENERIC_HWEIGHT=y
CONFIG_GENERIC_CALIBRATE_DELAY=y
CONFIG_ARCH_MTD_XIP=y
CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
CONFIG_VECTORS_BASE=0xffff0000
CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"

#
# General setup
#
CONFIG_EXPERIMENTAL=y
CONFIG_BROKEN_ON_SMP=y
CONFIG_INIT_ENV_ARG_LIMIT=32
CONFIG_LOCALVERSION=""
CONFIG_LOCALVERSION_AUTO=y
CONFIG_SWAP=y
CONFIG_SYSVIPC=y
CONFIG_SYSVIPC_SYSCTL=y
# CONFIG_POSIX_MQUEUE is not set
# CONFIG_BSD_PROCESS_ACCT is not set
# CONFIG_TASKSTATS is not set
# CONFIG_AUDIT is not set
# CONFIG_IKCONFIG is not set
CONFIG_LOG_BUF_SHIFT=14
# CONFIG_CGROUPS is not set
# CONFIG_GROUP_SCHED is not set
# CONFIG_SYSFS_DEPRECATED_V2 is not set
# CONFIG_RELAY is not set
# CONFIG_NAMESPACES is not set
# CONFIG_BLK_DEV_INITRD is not set
# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
CONFIG_SYSCTL=y
CONFIG_EMBEDDED=y
CONFIG_UID16=y
CONFIG_SYSCTL_SYSCALL=y
# CONFIG_KALLSYMS is not set
CONFIG_HOTPLUG=y
CONFIG_PRINTK=y
CONFIG_BUG=y
CONFIG_ELF_CORE=y
# CONFIG_COMPAT_BRK is not set
CONFIG_BASE_FULL=y
CONFIG_FUTEX=y
CONFIG_ANON_INODES=y
CONFIG_EPOLL=y
CONFIG_SIGNALFD=y
CONFIG_TIMERFD=y
CONFIG_EVENTFD=y
CONFIG_SHMEM=y
CONFIG_AIO=y
CONFIG_VM_EVENT_COUNTERS=y
CONFIG_SLAB=y
# CONFIG_SLUB is not set
# CONFIG_SLOB is not set
# CONFIG_PROFILING is not set
# CONFIG_MARKERS is not set
CONFIG_HAVE_OPROFILE=y
CONFIG_HAVE_KPROBES=y
CONFIG_HAVE_KRETPROBES=y
CONFIG_HAVE_CLK=y
CONFIG_HAVE_GENERIC_DMA_COHERENT=y
CONFIG_SLABINFO=y
CONFIG_RT_MUTEXES=y
# CONFIG_TINY_SHMEM is not set
CONFIG_BASE_SMALL=0
CONFIG_MODULES=y
# CONFIG_MODULE_FORCE_LOAD is not set
CONFIG_MODULE_UNLOAD=y
CONFIG_MODULE_FORCE_UNLOAD=y
# CONFIG_MODVERSIONS is not set
# CONFIG_MODULE_SRCVERSION_ALL is not set
CONFIG_KMOD=y
CONFIG_BLOCK=y
# CONFIG_LBD is not set
# CONFIG_BLK_DEV_IO_TRACE is not set
# CONFIG_LSF is not set
# CONFIG_BLK_DEV_BSG is not set
# CONFIG_BLK_DEV_INTEGRITY is not set

#
# IO Schedulers
#
CONFIG_IOSCHED_NOOP=y
CONFIG_IOSCHED_AS=y
# CONFIG_IOSCHED_DEADLINE is not set
# CONFIG_IOSCHED_CFQ is not set
CONFIG_DEFAULT_AS=y
# CONFIG_DEFAULT_DEADLINE is not set
# CONFIG_DEFAULT_CFQ is not set
# CONFIG_DEFAULT_NOOP is not set
CONFIG_DEFAULT_IOSCHED="anticipatory"
CONFIG_CLASSIC_RCU=y
CONFIG_FREEZER=y

#
# System Type
#
# CONFIG_ARCH_AAEC2000 is not set
# CONFIG_ARCH_INTEGRATOR is not set
# CONFIG_ARCH_REALVIEW is not set
# CONFIG_ARCH_VERSATILE is not set
# CONFIG_ARCH_AT91 is not set
# CONFIG_ARCH_CLPS711X is not set
# CONFIG_ARCH_EBSA110 is not set
# CONFIG_ARCH_EP93XX is not set
# CONFIG_ARCH_FOOTBRIDGE is not set
# CONFIG_ARCH_NETX is not set
# CONFIG_ARCH_H720X is not set
# CONFIG_ARCH_IMX is not set
# CONFIG_ARCH_IOP13XX is not set
# CONFIG_ARCH_IOP32X is not set
# CONFIG_ARCH_IOP33X is not set
# CONFIG_ARCH_IXP23XX is not set
# CONFIG_ARCH_IXP2000 is not set
# CONFIG_ARCH_IXP4XX is not set
# CONFIG_ARCH_L7200 is not set
# CONFIG_ARCH_KIRKWOOD is not set
# CONFIG_ARCH_KS8695 is not set
# CONFIG_ARCH_NS9XXX is not set
# CONFIG_ARCH_LOKI is not set
# CONFIG_ARCH_MV78XX0 is not set
# CONFIG_ARCH_MXC is not set
# CONFIG_ARCH_ORION5X is not set
# CONFIG_ARCH_PNX4008 is not set
CONFIG_ARCH_PXA=y
# CONFIG_ARCH_RPC is not set
# CONFIG_ARCH_SA1100 is not set
# CONFIG_ARCH_S3C2410 is not set
# CONFIG_ARCH_SHARK is not set
# CONFIG_ARCH_LH7A40X is not set
# CONFIG_ARCH_DAVINCI is not set
# CONFIG_ARCH_OMAP is not set
# CONFIG_ARCH_MSM is not set
# CONFIG_ARCH_W90X900 is not set

#
# Intel PXA2xx/PXA3xx Implementations
#
# CONFIG_ARCH_GUMSTIX is not set
# CONFIG_ARt reg = 0;
                UxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,
                        &pcidata);
                if (UxxxStatus)
                        return UxxxStatus;
                pciVID = pcidata & 0xFFFF;
                pciPID = (pcidata >> 16) & 0xFFFF;
                if (pciVID == ftdi->platform_data.vendor && pciPID ==
                        ftdi->platform_data.device) {
                        return 0;
                } else {
                        dev_err(&ftdi->udev->dev, "vendor=%04X pciVID=%04X devi"
                                "ce=%04X pciPID=%04X\n",
                                ftdi->platform_data.vendor, pciVID,
                                ftdi->platform_data.device, pciPID);
                        return -ENODEV;
                }
        }
}


#define ftdi_read_pcimem(ftdi, member, data) ftdi_elan_read_pcimem(ftdi, \
        offsetof(struct ohci_regs, member), 0, data);
#define ftdi_write_pcimem(ftdi, member, data) ftdi_elan_write_pcimem(ftdi, \
        offsetof(struct ohci_regs, member), 0, data);

#define OHCI_CONTROL_INIT OHCI_CTRL_CBSR
#define OHCI_INTR_INIT (OHCI_INTR_MIE | OHCI_INTR_UE | OHCI_INTR_RD | \
        OHCI_INTR_WDH)
static int ftdi_elan_check_controller(struct usb_ftdi *ftdi, int quirk)
{
        int devices = 0;
        int retval;
        u32 hc_control;
        int num_ports;
        u32 control;
        u32 rh_a = -1;
        u32 status;
        u32 fminterval;
        u32 hc_fminterval;
        u32 periodicstart;
        u32 cmdstatus;
        u32 roothub_a;
        int mask = OHCI_INTR_INIT;
        int sleep_time = 0;
        int reset_timeout = 30;        /* ... allow extra time */
        int temp;
        retval = ftdi_write_pcimem(ftdi, intrdisable, OHCI_INTR_MIE);
        if (retval)
                return retval;
        retval = ftdi_read_pcimem(ftdi, control, &control);
        if (retval)
                return retval;
        retval = ftdi_read_pcimem(ftdi, roothub.a, &rh_a);
        if (retval)
                return retval;
        num_ports = rh_a & RH_A_NDP;
        retval = ftdi_read_pcimem(ftdi, fminterval, &hc_fminterval);
        if (retval)
                return retval;
        hc_fminterval &= 0x3fff;
        if (hc_fminterval != FI) {
        }
        hc_fminterval |= FSMP(hc_fminterval) << 16;
        retval = ftdi_read_pcimem(ftdi, control, &hc_control);
        if (retval)
                return retval;
        switch (hc_control & OHCI_CTRL_HCFS) {
        case OHCI_USB_OPER:
                sleep_time = 0;
                break;
        case OHCI_USB_SUSPEND:
        case OHCI_USB_RESUME:
                hc_control &= OHCI_CTRL_RWC;
                hc_control |= OHCI_USB_RESUME;
                sleep_time = 10;
                break;
        default:
                hc_control &= OHCI_CTRL_RWC;
                hc_control |= OHCI_USB_RESET;
                sleep_time = 50;
                break;
        }
        retval = ftdi_write_pcimem(ftdi, control, hc_control);
        if (retval)
                return retval;
        retval = ftdi_read_pcimem(ftdi, control, &control);
        if (retval)
                return retval;
        msleep(sleep_time);
        retval = ftdi_read_pcimem(ftdi, roothub.a, &roothub_a);
        if (retval)
                return retval;
        if (!(roothub_a & RH_A_NPS)) {        /* power down each port */
                for (temp = 0; temp < num_ports; temp++) {
                        retval = ftdi_write_pcimem(ftdi,
                                roothub.portstatus[temp], RH_PS_LSDA);
                        if (retval)
                                return retval;
                }
        }
        retval = ftdi_read_pcimem(ftdi, control, &control);
        if (retval)
                return retval;
      retry:retval = ftdi_read_pcimem(ftdi, cmdstatus, &status);
        if (retval)
                return retval;
        retval = ftdi_write_pcimem(ftdi, cmdstatus, OHCI_HCR);
        if (retval)
                return retval;
      extra:{
                retval =CED is not set
CONFIG_TCP_CONG_CUBIC=y
CONFIG_DEFAULT_TCP_CONG="cubic"
# CONFIG_TCP_MD5SIG is not set
# CONFIG_IPV6 is not set
# CONFIG_NETWORK_SECMARK is not set
# CONFIG_NETFILTER is not set
# CONFIG_IP_DCCP is not set
# CONFIG_IP_SCTP is not set
# CONFIG_TIPC is not set
# CONFIG_ATM is not set
# CONFIG_BRIDGE is not set
# CONFIG_NET_DSA is not set
# CONFIG_VLAN_8021Q is not set
# CONFIG_DECNET is not set
# CONFIG_LLC2 is not set
# CONFIG_IPX is not set
# CONFIG_ATALK is not set
# CONFIG_X25 is not set
# CONFIG_LAPB is not set
# CONFIG_ECONET is not set
# CONFIG_WAN_ROUTER is not set
# CONFIG_NET_SCHED is not set

#
# Network testing
#
# CONFIG_NET_PKTGEN is not set
# CONFIG_HAMRADIO is not set
# CONFIG_CAN is not set
CONFIG_IRDA=y

#
# IrDA protocols
#
CONFIG_IRLAN=m
CONFIG_IRCOMM=m
CONFIG_IRDA_ULTRA=y

#
# IrDA options
#
CONFIG_IRDA_CACHE_LAST_LSAP=y
CONFIG_IRDA_FAST_RR=y
# CONFIG_IRDA_DEBUG is not set

#
# Infrared-port device drivers
#

#
# SIR device drivers
#
# CONFIG_IRTTY_SIR is not set

#
# Dongle support
#

#
# FIR device drivers
#
CONFIG_PXA_FICP=y
# CONFIG_BT is not set
# CONFIG_AF_RXRPC is not set
# CONFIG_PHONET is not set
CONFIG_WIRELESS=y
CONFIG_CFG80211=m
CONFIG_NL80211=y
CONFIG_WIRELESS_OLD_REGULATORY=y
CONFIG_WIRELESS_EXT=y
CONFIG_WIRELESS_EXT_SYSFS=y
CONFIG_MAC80211=m

#
# Rate control algorithm selection
#
CONFIG_MAC80211_RC_PID=y
# CONFIG_MAC80211_RC_MINSTREL is not set
CONFIG_MAC80211_RC_DEFAULT_PID=y
# CONFIG_MAC80211_RC_DEFAULT_MINSTREL is not set
CONFIG_MAC80211_RC_DEFAULT="pid"
# CONFIG_MAC80211_MESH is not set
# CONFIG_MAC80211_LEDS is not set
# CONFIG_MAC80211_DEBUG_MENU is not set
CONFIG_IEEE80211=m
# CONFIG_IEEE80211_DEBUG is not set
CONFIG_IEEE80211_CRYPT_WEP=m
CONFIG_IEEE80211_CRYPT_CCMP=m
CONFIG_IEEE80211_CRYPT_TKIP=m
# CONFIG_RFKILL is not set
# CONFIG_NET_9P is not set

#
# Device Drivers
#

#
# Generic Driver Options
#
CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
# CONFIG_STANDALONE is not set
CONFIG_PREVENT_FIRMWARE_BUILD=y
CONFIG_FW_LOADER=y
CONFIG_FIRMWARE_IN_KERNEL=y
CONFIG_EXTRA_FIRMWARE=""
# CONFIG_SYS_HYPERVISOR is not set
# CONFIG_CONNECTOR is not set
CONFIG_MTD=m
# CONFIG_MTD_DEBUG is not set
# CONFIG_MTD_CONCAT is not set
# CONFIG_MTD_PARTITIONS is not set

#
# User Modules And Translation Layers
#
# CONFIG_MTD_CHAR is not set
# CONFIG_MTD_BLKDEVS is not set
# CONFIG_MTD_BLOCK is not set
# CONFIG_MTD_BLOCK_RO is not set
# CONFIG_FTL is not set
# CONFIG_NFTL is not set
# CONFIG_INFTL is not set
# CONFIG_RFD_FTL is not set
# CONFIG_SSFDC is not set
# CONFIG_MTD_OOPS is not set

#
# RAM/ROM/Flash chip drivers
#
# CONFIG_MTD_CFI is not set
# CONFIG_MTD_JEDECPROBE is not set
CONFIG_MTD_MAP_BANK_WIDTH_1=y
CONFIG_MTD_MAP_BANK_WIDTH_2=y
CONFIG_MTD_MAP_BANK_WIDTH_4=y
# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
CONFIG_MTD_CFI_I1=y
CONFIG_MTD_CFI_I2=y
# CONFIG_MTD_CFI_I4 is not set
# CONFIG_MTD_CFI_I8 is not set
# CONFIG_MTD_RAM is not set
# CONFIG_MTD_ROM is not set
# CONFIG_MTD_ABSENT is not set

#
# Mapping drivers for chip access
#
# CONFIG_MTD_COMPLEX_MAPPINGS is not set
# CONFIG_MTD_SHARP_SL is not set
# CONFIG_MTD_PLATRAM is not set

#
# Self-contained MTD device drivers
#
# CONFIG_MTD_SLRAM is not set
# CONFIG_MTD_PHRAM is not set
# CONFIG_MTD_MTDRAM is not set
# CONFIG_MTD_BLOCK2MTD is not set

#
# Disk-On-Chip Device Drivers
#
# CONFIG_MTD_DOC2000 is not set
# CONFIG_MTD_DOC2001 is not set
# CONFIG_MTD_DOC2001PLUS is not set
CONFIG_MTD_NAND=m
# CONFIG_MTD_NAND_VERIFY_WRITE is not set
# CONFIG_MTD_NAND_ECC_SMC is not set
# CONFIG_MTD_NAND_MUSEUM_IDS is not set
# CONFIG_MTD_NAND_GPIO is not set
CONFIG_MTD_NAND_IDS=m
# CONFIG_MTD_NAND_DISKONCHIP is not set
# CONFIG_MTD_NAND_SHARPSL is not set
CONFIG_MTD_NAND_TMIO=m
# CONFIG_MTD_NAND_PLATFORM is not set
# CONFIG_MTD_ONENAND is not set

#
# UBI - Unsorted block images
#
# CONFIG_MTD_UBI is not set
# CONFIG_PARPORT is not set
CONFIG_BLK_DEV=y
# CONFIG_BLK_DEV_COW_COMMON is not set
CONFIG_BLK_DEV_LOOP=m
# CONFIG_BLK_DEV_CRYPTOLOOP is not set
# CONFIG_BLKothub.a, roothub_a);
                if (retval)
                        return retval;
        }
        retval = ftdi_write_pcimem(ftdi, roothub.status, RH_HS_LPSC);
        if (retval)
                return retval;
        retval = ftdi_write_pcimem(ftdi, roothub.b,
                (roothub_a & RH_A_NPS) ? 0 : RH_B_PPCM);
        if (retval)
                return retval;
        retval = ftdi_read_pcimem(ftdi, control, &control);
        if (retval)
                return retval;
        mdelay((roothub_a >> 23) & 0x1fe);
        for (temp = 0; temp < num_ports; temp++) {
                u32 portstatus;
                retval = ftdi_read_pcimem(ftdi, roothub.portstatus[temp],
                        &portstatus);
                if (retval)
                        return retval;
                if (1 & portstatus)
                        devices += 1;
        }
        return devices;
}

static int ftdi_elan_setup_controller(struct usb_ftdi *ftdi, int fn)
{
        u32 latence_timer;
        int UxxxStatus;
        u32 pcidata;
        int reg = 0;
        int activePCIfn = fn << 8;
        UxxxStatus = ftdi_elan_write_reg(ftdi, 0x0000025FL | 0x2800);
        if (UxxxStatus)
                return UxxxStatus;
        reg = 16;
        UxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0,
                0xFFFFFFFF);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,
                &pcidata);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0,
                0xF0000000);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,
                &pcidata);
        if (UxxxStatus)
                return UxxxStatus;
        reg = 12;
        UxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,
                &latence_timer);
        if (UxxxStatus)
                return UxxxStatus;
        latence_timer &= 0xFFFF00FF;
        latence_timer |= 0x00001600;
        UxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0x00,
                latence_timer);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,
                &pcidata);
        if (UxxxStatus)
                return UxxxStatus;
        reg = 4;
        UxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0x00,
                0x06);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,
                &pcidata);
        if (UxxxStatus)
                return UxxxStatus;
        for (reg = 0; reg <= 0x54; reg += 4) {
                UxxxStatus = ftdi_elan_read_pcimem(ftdi, reg, 0, &pcidata);
                if (UxxxStatus)
                        return UxxxStatus;
        }
        return 0;
}

static int ftdi_elan_close_controller(struct usb_ftdi *ftdi, int fn)
{
        u32 latence_timer;
        int UxxxStatus;
        u32 pcidata;
        int reg = 0;
        int activePCIfn = fn << 8;
        UxxxStatus = ftdi_elan_write_reg(ftdi, 0x0000025FL | 0x2800);
        if (UxxxStatus)
                return UxxxStatus;
        reg = 16;
        UxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0,
                0xFFFFFFFF);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,
                &pcidata);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0,
                0x00000000);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,
                &pcidata);
        if (UxxxStatus)
                return UxxxStatus;
        reg = 12;
        UxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,
                &latence_timer);
        if (UxxxStatus)
                return UxxxStatus;
        latence_timer &= 0xFFFF00FF;
        latence_timer |= 0x00001600;
        UxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0x00,
                latence_timer);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,
                &pcidata);
        if (UxxxStatus)
                return UxxxStatus;
        reg = 4;
        UxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0x00,
                0x00);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,
                &pcidata);
        if (UxxxStatus)
                return UxxxStatus;
        return 0;
}

static int ftdi_elan_found_controller(struct usb_ftdi *ftdi, int fn, int quirk)
{
        int result;
        int UxxxStatus;
        UxxxStatus = ftdi_elan_setup_controller(ftdi, fn);
        if (UxxxStatus)
                return UxxxStatus;
        result = ftdi_elan_check_controller(ftdi, quirk);
        UxxxStatus = ftdi_elan_close_controller(ftdi, fn);
        if (UxxxStatus)
                return UxxxStatus;
        return result;
}

static int ftdi_elan_enumeratePCI(struct usb_ftdi *ftdi)
{
        u32 controlreg;
        u8 sensebits;
        int UxxxStatus;
        UxxxStatus = ftdi_elan_read_reg(ftdi, &controlreg);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_write_reg(ftdi, 0x00000000L);
        if (UxxxStatus)
                return UxxxStatus;
        msleep(750);
        UxxxStatus = ftdi_elan_write_reg(ftdi, 0x00000200L | 0x100);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_write_reg(ftdi, 0x00000200L | 0x500);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_read_reg(ftdi, &controlreg);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_write_reg(ftdi, 0x0000020CL | 0x000);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_write_reg(ftdi, 0x0000020DL | 0x000);
        if (UxxxStatus)
                return UxxxStatus;
        msleep(250);
        UxxxStatus = ftdi_elan_write_reg(ftdi, 0x0000020FL | 0x000);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_read_reg(ftdi, &controlreg);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_write_reg(ftdi, 0x0000025FL | 0x800);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_read_reg(ftdi, &controlreg);
        if (UxxxStatus)
                return UxxxStatus;
        UxxxStatus = ftdi_elan_read_reg(ftdi, &controlreg);
        if (UxxxStatus)
                return UxxxStatus;
        msleep(1000);
        sensebits = (controlreg >> 16) & 0x000F;
        if (0x0D == sensebits)
                return 0;
        else
		return - ENXIO;
}

static int ftdi_elan_setupOHCI(struct usb_ftdi *ftdi)
{
        int UxxxStatus;
        u32 pcidata;
        int reg = 0;
        u8 fn;
        int activePCIfn = 0;
        int max_devices = 0;
        int controllers = 0;
        int unrecognized = 0;
        ftdi->function = 0;
        for (fn = 0; (fn < 4); fn++) {
                u32 pciVID = 0;
                u32 pciPID = 0;
                int devices = 0;
                activePCIfn = fn << 8;
                UxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,
                        &pcidata);
                if (UxxxStatus)
                        return UxxxStatus;
                pciVID = pcidata & 0xFFFF;
                pciPID = (pcidata >> 16) & 0xFFFF;
                if ((pciVID == PCI_VENDOR_ID_OPTI) && (pciPID == 0xc861)) {
                        devices = ftdi_elan_found_controller(ftdi, fn, 0);
                        controllers += 1;
                } else if ((pciVID == PCI_VENDOR_ID_NEC) && (pciPID == 0x0035))
                        {
                        devices = ftdi_elan_found_controller(ftdi, fn, 0);
                        controllers += 1;
                } else if ((pciVID == PCI_VENDOR_ID_AL) && (pciPID == 0x5237)) {
                        devices = ftdi_elan_found_controller(ftdi, fn, 0);
                        controllers += 1;
                } else if ((pciVID == PCI_VENDOR_ID_ATT) && (pciPID == 0x5802))
                        {
                        devices = ftdi_elan_found_controller(ftdi, fn, 0);
                        controllers += 1;
                } else if (pciVID == PCI_VENDOR_ID_AMD && pciPID == 0x740c) {
                        devices = ftdi_elan_found_controller(ftdi, fn,
                                OHCI_QUIRK_AMD756);
                        controllers += 1;
                } else if (pciVID == PCI_VENDOR_ID_COMPAQ && pciPID == 0xa0f8) {
                        devices = ftdi_elan_found_controller(ftdi, fn,
                                OHCI_QUIRK_ZFMICRO);
                        controllers += 1;
                } else if (0 == pcidata) {
                } else
                        unrecognized += 1;
                if (devices > max_devices) {
                        max_devices = devices;
                        ftdi->function = fn + 1;
                        ftdi->platform_data.vendor = pciVID;
                        ftdi->platform_data.device = pciPID;
                }
        }
        if (ftdi->function > 0) {
                UxxxStatus = ftdi_elan_setup_controller(ftdi,
                        ftdi->function - 1);
                if (UxxxStatus)
                        return UxxxStatus;
                return 0;
        } else if (controllers > 0) {
                return -ENXIO;
        } else if (unrecognized > 0) {
                return -ENXIO;
        } else {
                ftdi->enumerated = 0;
                return -ENXIO;
        }
}


/*
* we use only the first bulk-in and bulk-out endpoints
*/
static int ftdi_elan_probe(struct usb_interface *interface,
        const struct usb_device_id *id)
{
        struct usb_host_interface *iface_desc;
        struct usb_endpoint_descriptor *endpoint;
        size_t buffer_size;
        int i;
        int retval = -ENOMEM;
        struct usb_ftdi *ftdi;

	ftdi = kzalloc(sizeof(struct usb_ftdi), GFP_KERNEL);
	if (!ftdi) {
                printk(KERN_ERR "Out of memory\n");
                return -ENOMEM;
        }

        mutex_lock(&ftdi_module_lock);
        list_add_tail(&ftdi->ftdi_list, &ftdi_static_list);
        ftdi->sequence_num = ++ftdi_instances;
        mutex_unlock(&ftdi_module_lock);
        ftdi_elan_init_kref(ftdi);
        init_MUTEX(&ftdi->sw_lock);
        ftdi->udev = usb_get_dev(interface_to_usbdev(interface));
        ftdi->interface = interface;
        mutex_init(&ftdi->u132_lock);
        ftdi->expected = 4;
        iface_desc = interface->cur_altsetting;
        for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
                endpoint = &iface_desc->endpoint[i].desc;
                if (!ftdi->bulk_in_endpointAddr &&
		    usb_endpoint_is_bulk_in(endpoint)) {
                        buffer_size = le16_to_cpu(endpoint->wMaxPacketSize);
                        ftdi->bulk_in_size = buffer_size;
                        ftdi->bulk_in_endpointAddr = endpoint->bEndpointAddress;
                        ftdi->bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);
                        if (!ftdi->bulk_in_buffer) {
                                dev_err(&ftdi->udev->dev, "Could not allocate b"
                                        "ulk_in_buffer\n");
                                retval = -ENOMEM;
                                goto error;
                        }
                }
                if (!ftdi->bulk_out_endpointAddr &&
		    usb_endpoint_is_bulk_out(endpoint)) {
                        ftdi->bulk_out_endpointAddr =
                                endpoint->bEndpointAddress;
                }
        }
        if (!(ftdi->bulk_in_endpointAddr && ftdi->bulk_out_endpointAddr)) {
                dev_err(&ftdi->udev->dev, "Could not find both bulk-in and bulk"
                        "-out endpoints\n");
                retval = -ENODEV;
                goto error;
        }
        dev_info(&ftdi->udev->dev, "interface %d has I=%02X O=%02X\n",
                iface_desc->desc.bInterfaceNumber, ftdi->bulk_in_endpointAddr,
                ftdi->bulk_out_endpointAddr);
        usb_set_intfdata(interface, ftdi);
        if (iface_desc->desc.bInterfaceNumber == 0 &&
                ftdi->bulk_in_endpointAddr == 0x81 &&
                ftdi->bulk_out_endpointAddr == 0x02) {
                retval = usb_register_dev(interface, &ftdi_elan_jtag_class);
                if (retval) {
                        dev_err(&ftdi->udev->dev, "Not able to get a minor for "
                                "this device.\n");
                        usb_set_intfdata(interface, NULL);
                        retval = -ENOMEM;
                        goto error;
                } else {
                        ftdi->class = &ftdi_elan_jtag_class;
                        dev_info(&ftdi->udev->dev, "USB FDTI=%p JTAG interface "
                                "%d now attached to ftdi%d\n", ftdi,
                                iface_desc->desc.bInterfaceNumber,
                                interface->minor);
                        return 0;
                }
        } else if (iface_desc->desc.bInterfaceNumber == 1 &&
                ftdi->bulk_in_endpointAddr == 0x83 &&
                ftdi->bulk_out_endpointAddr == 0x04) {
                ftdi->class = NULL;
                dev_info(&ftdi->udev->dev, "USB FDTI=%p ELAN interface %d now a"
                        "ctivated\n", ftdi, iface_desc->desc.bInterfaceNumber);
                INIT_DELAYED_WORK(&ftdi->status_work, ftdi_elan_status_work);
                INIT_DELAYED_WORK(&ftdi->command_work, ftdi_elan_command_work);
                INIT_DELAYED_WORK(&ftdi->respond_work, ftdi_elan_respond_work);
                ftdi_status_queue_work(ftdi, msecs_to_jiffies(3 *1000));
                return 0;
        } else {
                dev_err(&ftdi->udev->dev,
                        "Could not find ELAN's U132 device\n");
                retval = -ENODEV;
                goto error;
        }
      error:if (ftdi) {
                ftdi_elan_put_kref(ftdi);
        }
        return retval;
}

static void ftdi_elan_disconnect(struct usb_interface *interface)
{
        struct usb_ftdi *ftdi = usb_get_intfdata(interface);
        ftdi->disconnected += 1;
        if (ftdi->class) {
                int minor = interface->minor;
                struct usb_class_driver *class = ftdi->class;
                usb_set_intfdata(interface, NULL);
                usb_deregister_dev(interface, class);
                dev_info(&ftdi->udev->dev, "USB FTDI U132 jtag interface on min"
                        "or %d now disconnected\n", minor);
        } else {
                ftdi_status_cancel_work(ftdi);
                ftdi_command_cancel_work(ftdi);
                ftdi_response_cancel_work(ftdi);
                ftdi_elan_abandon_completions(ftdi);
                ftdi_elan_abandon_targets(ftdi);
                if (ftdi->registered) {
                        platform_device_unregister(&ftdi->platform_dev);
                        ftdi->synchronized = 0;
                        ftdi->enumerated = 0;
                        ftdi->initialized = 0;
                        ftdi->registered = 0;
                }
                flush_workqueue(status_queue);
                flush_workqueue(command_queue);
                flush_workqueue(respond_queue);
                ftdi->disconnected += 1;
                usb_set_intfdata(interface, NULL);
                dev_info(&ftdi->udev->dev, "USB FTDI U132 host controller inter"
                        "face now disconnected\n");
        }
        ftdi_elan_put_kref(ftdi);
}

static struct usb_driver ftdi_elan_driver = {
        .name = "ftdi-elan",
        .probe = ftdi_elan_probe,
        .disconnect = ftdi_elan_disconnect,
        .id_table = ftdi_elan_table,
};
static int __init ftdi_elan_init(void)
{
        int result;
        printk(KERN_INFO "driver %s built at %s on %s\n", ftdi_elan_driver.name,
	       __TIME__, __DATE__);
        mutex_init(&ftdi_mo