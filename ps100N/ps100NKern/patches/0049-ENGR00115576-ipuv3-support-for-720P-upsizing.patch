pu_to_le32(cmd);
		risc->jmp[1] = cpu_to_le32(next);
		btv->main.cpu[slot+1] = cpu_to_le32(risc->dma);
	}
	return 0;
}

void
bttv_dma_free(struct videobuf_queue *q,struct bttv *btv, struct bttv_buffer *buf)
{
	struct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);

	BUG_ON(in_interrupt());
	videobuf_waiton(&buf->vb,0,0);
	videobuf_dma_unmap(q, dma);
	videobuf_dma_free(dma);
	btcx_riscmem_free(btv->c.pci,&buf->bottom);
	btcx_riscmem_free(btv->c.pci,&buf->top);
	buf->vb.state = VIDEOBUF_NEEDS_INIT;
}

int
bttv_buffer_activate_vbi(struct bttv *btv,
			 struct bttv_buffer *vbi)
{
	struct btcx_riscmem *top;
	struct btcx_riscmem *bottom;
	int top_irq_flags;
	int bottom_irq_flags;

	top = NULL;
	bottom = NULL;
	top_irq_flags = 0;
	bottom_irq_flags = 0;

	if (vbi) {
		unsigned int crop, vdelay;

		vbi->vb.state = VIDEOBUF_ACTIVE;
		list_del(&vbi->vb.queue);

		/* VDELAY is start of video, end of VBI capturing. */
		crop = btread(BT848_E_CROP);
		vdelay = btread(BT848_E_VDELAY_LO) + ((crop & 0xc0) << 2);

		if (vbi->geo.vdelay > vdelay) {
			vdelay = vbi->geo.vdelay & 0xfe;
			crop = (crop & 0x3f) | ((vbi->geo.vdelay >> 2) & 0xc0);

			btwrite(vdelay, BT848_E_VDELAY_LO);
			btwrite(crop,	BT848_E_CROP);
			btwrite(vdelay, BT848_O_VDELAY_LO);
			btwrite(crop,	BT848_O_CROP);
		}

		if (vbi->vbi_count[0] > 0) {
			top = &vbi->top;
			top_irq_flags = 4;
		}

		if (vbi->vbi_count[1] > 0) {
			top_irq_flags = 0;
			bottom = &vbi->bottom;
			bottom_irq_flags = 4;
		}
	}

	bttv_risc_hook(btv, RISC_SLOT_O_VBI, top, top_irq_flags);
	bttv_risc_hook(btv, RISC_SLOT_E_VBI, bottom, bottom_irq_flags);

	return 0;
}

int
bttv_buffer_activate_video(struct bttv *btv,
			   struct bttv_buffer_set *set)
{
	/* video capture */
	if (NULL != set->top  &&  NULL != set->bottom) {
		if (set->top == set->bottom) {
			set->top->vb.state    = VIDEOBUF_ACTIVE;
			if (set->top->vb.queue.next)
				list_del(&set->top->vb.queue);
		} else {
			set->top->vb.state    = VIDEOBUF_ACTIVE;
			set->bottom->vb.state = VIDEOBUF_ACTIVE;
			if (set->top->vb.queue.next)
				list_del(&set->top->vb.queue);
			if (set->bottom->vb.queue.next)
				list_del(&set->bottom->vb.queue);
		}
		bttv_apply_geo(btv, &set->top->geo, 1);
		bttv_apply_geo(btv, &set->bottom->geo,0);
		bttv_risc_hook(btv, RISC_SLOT_O_FIELD, &set->top->top,
			       set->top_irq);
		bttv_risc_hook(btv, RISC_SLOT_E_FIELD, &set->bottom->bottom,
			       set->frame_irq);
		btaor((set->top->btformat & 0xf0) | (set->bottom->btformat & 0x0f),
		      ~0xff, BT848_COLOR_FMT);
		btaor((set->top->btswap & 0x0a) | (set->bottom->btswap & 0x05),
		      ~0x0f, BT848_COLOR_CTL);
	} else if (NULL != set->top) {
		set->top->vb.state  = VIDEOBUF_ACTIVE;
		if (set->top->vb.queue.next)
			list_del(&set->top->vb.queue);
		bttv_apply_geo(btv, &set->top->geo,1);
		bttv_apply_geo(btv, &set->top->geo,0);
		bttv_risc_hook(btv, RISC_SLOT_O_FIELD, &set->top->top,
			       set->frame_irq);
		bttv_risc_hook(btv, RISC_SLOT_E_FIELD, NULL,           0);
		btaor(set->top->btformat & 0xff, ~0xff, BT848_COLOR_FMT);
		btaor(set->top->btswap & 0x0f,   ~0x0f, BT848_COLOR_CTL);
	} else if (NULL != set->bottom) {
		set->bottom->vb.state = VIDEOBUF_ACTIVE;
		if (set->bottom->vb.queue.next)
			list_del(&set->bottom->vb.queue);
		bttv_apply_geo(btv, &set->bottom->geo,1);
		bttv_apply_geo(btv, &set->bottom->geo,0);
		bttv_risc_hook(btv, RISC_SLOT_O_FIELD, NULL, 0);
		bttv_risc_hook(btv, RISC_SLOT_E_FIELD, &set->bottom->bottom,
			       set->frame_irq);
		btaor(set->bottom->btformat & 0xff, ~0xff, BT848_COLOR_FMT);
		btaor(set->bottom->btswap & 0x0f,   ~0x0f, BT848_COLOR_CTL);
	} else {
		bttv_risc_hook(btv, RISC_SLOT_O_FIELD, NULL, 0);
		bttv_risc_hook(btv, RISC_SLOT_E_FIELD, NULL, 0);
	}
	return 0;
}

/* ---------------------------------------------------------- */

/* calculate geometry, build risc code */
int
bttv_buffer_risc(struct bttv *btv, struct bttv_buffer *buf)
{
	const struct bttv_tvnorm *tvnorm = bttv_tvnorms + buf->tvnorm;
	struct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);

	dprintk(KERN_DEBUG
		"bttv%d: buffer field: %s  format: %s  size: %dx%d\n",
		btv->c.nr, v4l2_field_names[buf->vb.field],
		buf->fmt->name, buf->vb.width, buf->vb.height);

	/* packed pixel modes */
	if (buf->fmt->flags & FORMAT_FLAGS_PACKED) {
		int bpl = (buf->fmt->depth >> 3) * buf->vb.width;
		int bpf = bpl * (buf->vb.height >> 1);

		bttv_calc_geo(btv,&buf->geo,buf->vb.width,buf->vb.height,
			      V4L2_FIELD_HAS_BOTH(buf->vb.field),
			      tvnorm,&buf->crop);

		switch (buf->vb.field) {
		case V4L2_FIELD_TOP:
			bttv_risc_packed(btv,&buf->top,dma->sglist,
					 /* offset */ 0,bpl,
					 /* padding */ 0,/* skip_lines */ 0,
					 buf->vb.height);
			break;
		case V4L2_FIELD_BOTTOM:
			bttv_risc_packed(btv,&buf->bottom,dma->sglist,
					 0,bpl,0,0,buf->vb.height);
			break;
		case V4L2_FIELD_INTERLACED:
			bttv_risc_packed(btv,&buf->top,dma->sglist,
					 0,bpl,bpl,0,buf->vb.height >> 1);
			bttv_risc_packed(btv,&buf->bottom,dma->sglist,
					 bpl,bpl,bpl,0,buf->vb.height >> 1);
			break;
		case V4L2_FIELD_SEQ_TB:
			bttv_risc_packed(btv,&buf->top,dma->sglist,
					 0,bpl,0,0,buf->vb.height >> 1);
			bttv_risc_packed(btv,&buf->bottom,dma->sglist,
					 bpf,bpl,0,0,buf->vb.height >> 1);
			break;
		default:
			BUG();
		}
	}

	/* planar modes */
	if (buf->fmt->flags & FORMAT_FLAGS_PLANAR) {
		int uoffset, voffset;
		int ypadding, cpadding, lines;

		/* calculate chroma offsets */
		uoffset = buf->vb.width * buf->vb.height;
		voffset = buf->vb.width * buf->vb.height;
		if (buf->fmt->flags & FORMAT_FLAGS_CrCb) {
			/* Y-Cr-Cb plane order */
			uoffset >>= buf->fmt->hshift;
			uoffset >>= buf->fmt->vshift;
			uoffset  += voffset;
		} else {
			/* Y-Cb-Cr plane order */
			voffset >>= buf->fmt->hshift;
			voffset >>= buf->fmt->vshift;
			voffset  += uoffset;
		}

		switch (buf->vb.field) {
		case V4L2_FIELD_TOP:
			bttv_calc_geo(btv,&buf->geo,buf->vb.width,
				      buf->vb.height,/* both_fields */ 0,
				      tvnorm,&buf->crop);
			bttv_risc_planar(btv, &buf->top, dma->sglist,
					 0,buf->vb.width,0,buf->vb.height,
					 uoffset,voffset,buf->fmt->hshift,
					 buf->fmt->vshift,0);
			break;
		case V4L2_FIELD_BOTTOM:
			bttv_calc_geo(btv,&buf->geo,buf->vb.width,
				      buf->vb.height,0,
				      tvnorm,&buf->crop);
			bttv_risc_planar(btv, &buf->bottom, dma->sglist,
					 0,buf->vb.width,0,buf->vb.height,
					 uoffset,voffset,buf->fmt->hshift,
					 buf->fmt->vshift,0);
			break;
		case V4L2_FIELD_INTERLACED:
			bttv_calc_geo(btv,&buf->geo,buf->vb.width,
				      buf->vb.height,1,
				      tvnorm,&buf->crop);
			lines    = buf->vb.height >> 1;
			ypadding = buf->vb.width;
			cpadding = buf->vb.width >> buf->fmt->hshift;
			bttv_risc_planar(btv,&buf->top,
					 dma->sglist,
					 0,buf->vb.width,ypadding,lines,
					 uoffset,voffset,
					 buf->fmt->hshift,
					 buf->fmt->vshift,
					 cpadding);
			bttv_risc_planar(btv,&buf->bottom,
					 dma->sglist,
					 ypadding,buf->vb.width,ypadding,lines,
					 uoffset+cpadding,
					 voffset+cpadding,
					 buf->fmt->hshift,
					 buf->fmt->vshift,
					 cpadding);
			break;
		case V4L2_FIELD_SEQ_TB:
			bttv_calc_geo(btv,&buf->geo,buf->vb.width,
				      buf->vb.height,1,
				      tvnorm,&buf->crop);
			lines    = buf->vb.height >> 1;
			ypadding = buf->vb.width;
			cpadding = buf->vb.width >> buf->fmt->hshift;
			bttv_risc_planar(btv,&buf->top,
					 dma->sglist,
					 0,buf->vb.width,0,lines,
					 uoffset >> 1,
					 voffset >> 1,
					 buf->fmt->hshift,
					 buf->fmt->vshift,
					 0);
			bttv_risc_planar(btv,&buf->bottom,
					 dma->sglist,
					 lines * ypadding,buf->vb.width,0,lines,
					 lines * ypadding + (uoffset >> 1),
					 lines * ypadding + (voffset >> 1),
					 buf->fmt->hshift,
					 buf->fmt->vshift,
					 0);
			break;
		default:
			BUG();
		}
	}

	/* raw data */
	if (buf->fmt->flags & FORMAT_FLAGS_RAW) {
		/* build risc code */
		buf->vb.field = V4L2_FIELD_SEQ_TB;
		bttv_calc_geo(btv,&buf->geo,tvnorm->swidth,tvnorm->sheight,
			      1,tvnorm,&buf->crop);
		bttv_risc_packed(btv, &buf->top,  dma->sglist,
				 /* offset */ 0, RAW_BPL, /* padding */ 0,
				 /* skip_lines */ 0, RAW_LINES);
		bttv_risc_packed(btv, &buf->bottom, dma->sglist,
				 buf->vb.size/2 , RAW_BPL, 0, 0, RAW_LINES);
	}

	/* copy format info */
	buf->btformat = buf->fmt->btformat;
	buf->btswap   = buf->fmt->btswap;
	return 0;
}

/* ---------------------------------------------------------- */

/* calculate geometry, build risc code */
int
bttv_overlay_risc(struct bttv *btv,
		  struct bttv_overlay *ov,
		  const struct bttv_format *fmt,
		  struct bttv_buffer *buf)
{
	/* check interleave, bottom+top fields */
	dprintk(KERN_DEBUG
		"bttv%d: overlay fields: %s format: %s  size: %dx%d\n",
		btv->c.nr, v4l2_field_names[buf->vb.field],
		fmt->name,ov->w.width,ov->w.height);

	/* calculate geometry */
	bttv_calc_geo(btv,&buf->geo,ov->w.width,ov->w.height,
		      V4L2_FIELD_HAS_BOTH(ov->field),
		      &bttv_tvnorms[ov->tvnorm],&buf->crop);

	/* build risc code */
	switch (ov->field) {
	case V4L2_FIELD_TOP:
		bttv_risc_overlay(btv, &buf->top,    fmt, ov, 0, 0);
		break;
	case V4L2_FIELD_BOTTOM:
		bttv_risc_overlay(btv, &buf->bottom, fmt, ov, 0, 0);
		break;
	case V4L2_FIELD_INTERLACED:
		bttv_risc_overlay(btv, &buf->top,    fmt, ov, 0, 1);
		bttv_risc_overlay(btv, &buf->bottom, fmt, ov, 1, 0);
		break;
	default:
		BUG();
	}

	/* copy format info */
	buf->btformat = fmt->btformat;
	buf->btswap   = fmt->btswap;
	buf->vb.field = ov->field;
	return 0;
}

/*
 * Local variables:
 * c-basic-offset: 8
 * End:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * linux/drivers/video/riva/fbdev-i2c.c - nVidia i2c
 *
 * Maintained by Ani Joshi <ajoshi@shell.unixbox.com>
 *
 * Copyright 2004 Antonino A. Daplas <adaplas @pol.net>
 *
 * Based on radeonfb-i2c.c
 *
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file COPYING in the main directory of this archive
 * for more details.
 */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/delay.h>
#include <linux/pci.h>
#include <linux/fb.h>
#include <linux/jiffies.h>

#include <asm/io.h>

#include "rivafb.h"
#include "../edid.h"

static void riva_gpio_setscl(void* data, int state)
{
	struct riva_i2c_chan 	*chan = data;
	struct riva_par 	*par = chan->par;
	u32			val;

	VGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base + 1);
	val = VGA_RD08(par->riva.PCIO, 0x3d5) & 0xf0;

	if (state)
		val |= 0x20;
	else
		val &= ~0x20;

	VGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base + 1);
	VGA_WR08(par->riva.PCIO, 0x3d5, val | 0x1);
}

static void riva_gpio_setsda(void* data, int state)
{
	struct riva_i2c_chan 	*chan = data;
	struct riva_par 	*par = chan->par;
	u32			val;

	VGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base + 1);
	val = VGA_RD08(par->riva.PCIO, 0x3d5) & 0xf0;

	if (state)
		val |= 0x10;
	else
		val &= ~0x10;

	VGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base + 1);
	VGA_WR08(par->riva.PCIO, 0x3d5, val | 0x1);
}

static int riva_gpio_getscl(void* data)
{
	struct riva_i2c_chan 	*chan = data;
	struct riva_par 	*par = chan->par;
	u32			val = 0;

	VGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base);
	if (VGA_RD08(par->riva.PCIO, 0x3d5) & 0x04)
		val = 1;

	return val;
}

static int riva_gpio_getsda(void* data)
{
	struct riva_i2c_chan 	*chan = data;
	struct riva_par 	*par = chan->par;
	u32			val = 0;

	VGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base);
	if (VGA_RD08(par->riva.PCIO, 0x3d5) & 0x08)
		val = 1;

	return val;
}

static int __devinit riva_setup_i2c_bus(struct riva_i2c_chan *chan,
					const char *name,
					unsigned int i2c_class)
{
	int rc;

	strcpy(chan->adapter.name, name);
	chan->adapter.owner		= THIS_MODULE;
	chan->adapter.id		= I2C_HW_B_RIVA;
	chan->adapter.class		= i2c_class;
	chan->adapter.algo_data		= &chan->algo;
	chan->adapter.dev.parent	= &chan->par->pdev->dev;
	chan->algo.setsda		= riva_gpio_setsda;
	chan->algo.setscl		= riva_gpio_setscl;
	chan->algo.getsda		= riva_gpio_getsda;
	chan->algo.getscl		= riva_gpio_getscl;
	chan->algo.udelay		= 40;
	chan->algo.timeout		= msecs_to_jiffies(2);
	chan->algo.data 		= chan;

	i2c_set_adapdata(&chan->adapter, chan);

	/* Raise SCL and SDA */
	riva_gpio_setsda(chan, 1);
	riva_gpio_setscl(chan, 1);
	udelay(20);

	rc = i2c_bit_add_bus(&chan->adapter);
	if (rc == 0)
		dev_dbg(&chan->par->pdev->dev, "I2C bus %s registered.\n", name);
	else {
		dev_warn(&chan->par->pdev->dev,
			 "Failed to register I2C bus %s.\n", name);
		chan->par = NULL;
	}

	return rc;
}

void __devinit riva_create_i2c_busses(struct riva_par *par)
{
	par->chan[0].par	= par;
	par->chan[1].par	= par;
	par->chan[2].par        = par;

	par->chan[0].ddc_base = 0x36;
	par->chan[1].ddc_base = 0x3e;
	par->chan[2].ddc_base = 0x50;
	riva_setup_i2c_bus(&par->chan[0], "BUS1", I2C_CLASS_HWMON);
	riva_setup_i2c_bus(&par->chan[1], "BUS2", 0);
	riva_setup_i2c_bus(&par->chan[2], "BUS3", 0);
}

void riva_delete_i2c_busses(struct riva_par *par)
{
	int i;

	for (i = 0; i < 3; i++) {
		if (!par->chan[i].par)
			continue;
		i2c_del_adapter(&par->chan[i].adapter);
		par->chan[i].par = NULL;
	}
}

int __devinit riva_probe_i2c_connector(struct riva_par *par, int conn, u8 **out_edid)
{
	u8 *edid = NULL;

	if (par->chan[conn].par)
		edid = fb_ddc_read(&par->chan[conn].adapter);

	if (out_edid)
		*out_edid = edid;
	if (!edid)
		return 1;

	return 0;
}

                                                                                                                                                                                                                                                                                                                                                    /*
 * DO NOT EDIT - This file is automatically generated
 *		 from the following source files:
 *
 * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#58 $
 * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#40 $
 */
static const uint8_t seqprog[] = {
	0xb2, 0x00, 0x00, 0x08,
	0xf7, 0x11, 0x22, 0x08,
	0x00, 0x65, 0xee, 0x59,
	0xf7, 0x01, 0x02, 0x08,
	0xff, 0x6a, 0x24, 0x08,
	0x40, 0x00, 0x40, 0x68,
	0x08, 0x1f, 0x3e, 0x10,
	0x40, 0x00, 0x40, 0x68,
	0xff, 0x40, 0x3c, 0x60,
	0x08, 0x1f, 0x3e, 0x10,
	0x60, 0x0b, 0x42, 0x68,
	0x40, 0xfa, 0x12, 0x78,
	0x01, 0x4d, 0xc8, 0x30,
	0x00, 0x4c, 0x12, 0x70,
	0x01, 0x39, 0xa2, 0x30,
	0x00, 0x6a, 0xc2, 0x5e,
	0x01, 0x51, 0x20, 0x31,
	0x01, 0x57, 0xae, 0x00,
	0x0d, 0x6a, 0x76, 0x00,
	0x00, 0x51, 0x14, 0x5e,
	0x01, 0x51, 0xc8, 0x30,
	0x00, 0x39, 0xc8, 0x60,
	0x00, 0xbb, 0x30, 0x70,
	0xc1, 0x6a, 0xda, 0x5e,
	0x01, 0xbf, 0x72, 0x30,
	0x01, 0x40, 0x7e, 0x31,
	0x01, 0x90, 0x80, 0x30,
	0x01, 0xf6, 0xd4, 0x30,
	0x01, 0x4d, 0x9a, 0x18,
	0xfe, 0x57, 0xae, 0x08,
	0x01, 0x40, 0x20, 0x31,
	0x00, 0x65, 0xcc, 0x58,
	0x60, 0x0b, 0x40, 0x78,
	0x08, 0x6a, 0x18, 0x00,
	0x08, 0x11, 0x22, 0x00,
	0x60, 0x0b, 0x00, 0x78,
	0x40, 0x0b, 0xfa, 0x68,
	0x80, 0x0b, 0xb6, 0x78,
	0x20, 0x6a, 0x16, 0x00,
	0xa4, 0x6a, 0x06, 0x00,
	0x08, 0x6a, 0x78, 0x00,
	0x01, 0x50, 0xc8, 0x30,
	0xe0, 0x6a, 0xcc, 0x00,
	0x48, 0x6a, 0xfe, 0x5d,
	0x01, 0x6a, 0xdc, 0x01,
	0x88, 0x6a, 0xcc, 0x00,
	0x48, 0x6a, 0xfe, 0x5d,
	0x01, 0x6a, 0x26, 0x01,
	0xf0, 0x19, 0x7a, 0x08,
	0x0f, 0x18, 0xc8, 0x08,
	0x0f, 0x0f, 0xc8, 0x08,
	0x0f, 0x05, 0xc8, 0x08,
	0x00, 0x3d, 0x7a, 0x00,
	0x08, 0x1f, 0x6e, 0x78,
	0x80, 0x3d, 0x7a, 0x00,
	0x01, 0x3d, 0xd8, 0x31,
	0x01, 0x3d, 0x32, 0x31,
	0x10, 0x03, 0x4e, 0x79,
	0x00, 0x65, 0xf2, 0x58,
	0x80, 0x66, 0xae, 0x78,
	0x01, 0x66, 0xd8, 0x31,
	0x01, 0x66, 0x32, 0x31,
	0x3f, 0x66, 0x7c, 0x08,
	0x40, 0x66, 0x82, 0x68,
	0x01, 0x3c, 0x78, 0x00,
	0x10, 0x03, 0x9e, 0x78,
	0x00, 0x65, 0xf2, 0x58,
	0xe0, 0x66, 0xc8, 0x18,
	0x00, 0x65, 0xaa, 0x50,
	0xdd, 0x66, 0xc8, 0x18,
	0x00, 0x65, 0xaa, 0x48,
	0x01, 0x66, 0xd8, 0x31,
	0x01, 0x66, 0x32, 0x31,
	0x10, 0x03, 0x4e, 0x79,
	0x00, 0x65, 0xf2, 0x58,
	0x01, 0x66, 0xd8, 0x31,
	0x01, 0x66, 0x32, 0x31,
	0x01, 0x66, 0xac, 0x30,
	0x40, 0x3c, 0x78, 0x00,
	0xff, 0x6a, 0xd8, 0x01,
	0xff, 0x6a, 0x32, 0x01,
	0x10, 0x3c, 0x78, 0x00,
	0x02, 0x57, 0x40, 0x69,
	0x10, 0x03, 0x3e, 0x69,
	0x00, 0x65, 0x20, 0x41,
	0x02, 0x57, 0xae, 0x00,
	0x00, 0x65, 0x9e, 0x40,
	0x61, 0x6a, 0xda, 0x5e,
	0x08, 0x51, 0x20, 0x71,
	0x02, 0x0b, 0xb2, 0x78,
	0x00, 0x65, 0xae, 0x40,
	0x1a, 0x01, 0x02, 0x00,
	0xf0, 0x19, 0x7a, 0x08,
	0x0f, 0x0f, 0xc8, 0x08,
	0x0f, 0x05, 0xc8, 0x08,
	0x00, 0x3d, 0x7a, 0x00,
	0x08, 0x1f, 0xc4, 0x78,
	0x80, 0x3d, 0x7a, 0x00,
	0x20, 0x6a, 0x16, 0x00,
	0x00, 0x65, 0xcc, 0x41,
	0x00, 0x65, 0xb4, 0x5e,
	0x00, 0x65, 0x12, 0x40,
	0x20, 0x11, 0xd2, 0x68,
	0x20, 0x6a, 0x18, 0x00,
	0x20, 0x11, 0x22, 0x00,
	0xf7, 0x1f, 0xca, 0x08,
	0x80, 0xb9, 0xd8, 0x78,
	0x08, 0x65, 0xca, 0x00,
	0x01, 0x65, 0x3e, 0x30,
	0x01, 0xb9, 0x1e, 0x30,
	0x7f, 0xb9, 0x0a, 0x08,
	0x01, 0xb9, 0x0a, 0x30,
	0x01, 0x54, 0xca, 0x30,
	0x80, 0xb8, 0xe6, 0x78,
	0x80, 0x65, 0xca, 0x00,
	0x01, 0x65, 0x00, 0x34,
	0x01, 0x54, 0x00, 0x34,
	0x08, 0xb8, 0xee, 0x78,
	0x20, 0x01, 0x02, 0x00,
	0x02, 0xbd, 0x08, 0x34,
	0x01, 0xbd, 0x08, 0x34,
	0x08, 0x01, 0x02, 0x00,
	0x02, 0x0b, 0xf4, 0x78,
	0xf7, 0x01, 0x02, 0x08,
	0x01, 0x06, 0xcc, 0x34,
	0xb2, 0x00, 0x00, 0x08,
	0x01, 0x40, 0x20, 0x31,
	0x01, 0xbf, 0x80, 0x30,
	0x01, 0xb9, 0x7a, 0x30,
	0x3f, 0xba, 0x7c, 0x08,
	0x00, 0x65, 0xea, 0x58,
	0x80, 0x0b, 0xc4, 0x79,
	0x12, 0x01, 0x02, 0x00,
	0x01, 0xab, 0xac, 0x30,
	0xe4, 0x6a, 0x70, 0x5d,
	0x40, 0x6a, 0x16, 0x00,
	0x80, 0x3e, 0x86, 0x5d,
	0x20, 0xb8, 0x18, 0x79,
	0x20, 0x6a, 0x86, 0x5d,
	0x00, 0xab, 0x86, 0x5d,
	0x01, 0xa9, 0x78, 0x30,
	0x10, 0xb8, 0x20, 0x79,
	0xe4, 0x6a, 0x70, 0x5d,
	0x00, 0x65, 0xae, 0x40,
	0x10, 0x03, 0x3c, 0x69,
	0x08, 0x3c, 0x5a, 0x69,
	0x04, 0x3c, 0x92, 0x69,
	0x02, 0x3c, 0x98, 0x69,
	0x01, 0x3c, 0x44, 0x79,
	0xff, 0x6a, 0xa6, 0x00,
	0x00, 0x65, 0xa4, 0x59,
	0x00, 0x6a, 0xc2, 0x5e,
	0xff, 0x53, 0x30, 0x71,
	0x0d, 0x6a, 0x76, 0x00,
	0x00, 0x53, 0x14, 0x5e,
	0x00, 0x65, 0xea, 0x58,
	0x12, 0x01, 0x02, 0x00,
	0x00, 0x65, 0x18, 0x41,
	0xa4, 0x6a, 0x06, 0x00,
	0x00, 0x65, 0xf2, 0x58,
	0xfd, 0x57, 0xae, 0x08,
	0x00, 0x65, 0xae, 0x40,
	0xe4, 0x6a, 0x70, 0x5d,
	0x20, 0x3c, 0x4a, 0x79,
	0x02, 0x6a, 0x86, 0x5d,
	0x04, 0x6a, 0x86, 0x5d,
	0x01, 0x03, 0x4c, 0x69,
	0xf7, 0x11, 0x22, 0x08,
	0xff, 0x6a, 0x24, 0x08,
	0xff, 0x6a, 0x06, 0x08,
	0x01, 0x6a, 0x7e, 0x00,
	0x00, 0x65, 0xa4, 0x59,
	0x00, 0x65, 0x04, 0x40,
	0x80, 0x86, 0xc8, 0x08,
	0x01, 0x4f, 0xc8, 0x30,
	0x00, 0x50, 0x6c, 0x61,
	0xc4, 0x6a, 0x70, 0x5d,
	0x40, 0x3c, 0x68, 0x79,
	0x28, 0x6a, 0x86, 0x5d,
	0x00, 0x65, 0x4c, 0x41,
	0x08, 0x6a, 0x86, 0x5d,
	0x00, 0x65, 0x4c, 0x41,
	0x84, 0x6a, 0x70, 0x5d,
	0x00, 0x65, 0xf2, 0x58,
	0x01, 0x66, 0xc8, 0x30,
	0x01, 0x64, 0xd8, 0x31,
	0x01, 0x64, 0x32, 0x31,
	0x5b, 0x64, 0xc8, 0x28,
	0x30, 0x64, 0xca, 0x18,
	0x01, 0x6c, 0xc8, 0x30,
	0xff, 0x64, 0x8e, 0x79,
	0x08, 0x01, 0x02, 0x00,
	0x02, 0x0b, 0x80, 0x79,
	0x01, 0x64, 0x86, 0x61,
	0xf7, 0x01, 0x02, 0x08,
	0x01, 0x06, 0xd8, 0x31,
	0x01, 0x06, 0x32, 0x31,
	0xff, 0x64, 0xc8, 0x18,
	0xff, 0x64, 0x80, 0x69,
	0xf7, 0x3c, 0x78, 0x08,
	0x00, 0x65, 0x20, 0x41,
	0x40, 0xaa, 0x7e, 0x10,
	0x04, 0xaa, 0x70, 0x5d,
	0x00, 0x65, 0x58, 0x42,
	0xc4, 0x6a, 0x70, 0x5d,
	0xc0, 0x6a, 0x7e, 0x00,
	0x00, 0xa8, 0x86, 0x5d,
	0xe4, 0x6a, 0x06, 0x00,
	0x00, 0x6a, 0x86, 0x5d,
	0x00, 0x65, 0x4c, 0x41,
	0x10, 0x3c, 0xa8, 0x69,
	0x00, 0xbb, 0x8c, 0x44,
	0x18, 0x6a, 0xda, 0x01,
	0x01, 0x69, 0xd8, 0x31,
	0x1c, 0x6a, 0xd0, 0x01,
	0x09, 0xee, 0xdc, 0x01,
	0x80, 0xee, 0xb0, 0x79,
	0xff, 0x6a, 0xdc, 0x09,
	0x01, 0x93, 0x26, 0x01,
	0x03, 0x6a, 0x2a, 0x01,
	0x01, 0x69, 0x32, 0x31,
	0x1c, 0x6a, 0xe2, 0x5d,
	0x0a, 0x93, 0x26, 0x01,
	0x00, 0x65, 0xaa, 0x5e,
	0x01, 0x50, 0xa0, 0x18,
	0x02, 0x6a, 0x22, 0x05,
	0x1a, 0x01, 0x02, 0x00,
	0x80, 0x6a, 0x74, 0x00,
	0x40, 0x6a, 0x78, 0x00,
	0x40, 0x6a, 0x16, 0x00,
	0x00, 0x65, 0xda, 0x5d,
	0x01, 0x3f, 0xc8, 0x30,
	0xbf, 0x64, 0x58, 0x7a,
	0x80, 0x64, 0xa0, 0x73,
	0xa0, 0x64, 0x02, 0x74,
	0xc0, 0x64, 0xf6, 0x73,
	0xe0, 0x64, 0x32, 0x74,
	0x01, 0x6a, 0xda, 0x5e,
	0x00, 0x65, 0xcc, 0x41,
	0xf7, 0x11, 0x22, 0x08,
	0x01, 0x06, 0xd4, 0x30,
	0xff, 0x6a, 0x24, 0x08,
	0xf7, 0x01, 0x02, 0x08,
	0xc0, 0x6a, 0x78, 0x00,
	0x09, 0x0c, 0xe8, 0x79,
	0x08, 0x0c, 0x04, 0x68,
	0xb1, 0x6a, 0xda, 0x5e,
	0xff, 0x6a, 0x26, 0x09,
	0x12, 0x01, 0x02, 0x00,
	0x02, 0x6a, 0x08, 0x30,
	0xff, 0x6a, 0x08, 0x08,
	0xdf, 0x01, 0x02, 0x08,
	0x01, 0x6a, 0x7e, 0x00,
	0xc0, 0x6a, 0x78, 0x04,
	0xff, 0x6a, 0xc8, 0x08,
	0x08, 0xa4, 0x48, 0x19,
	0x00, 0xa5, 0x4a, 0x21,
	0x00, 0xa6, 0x4c, 0x21,
	0x00, 0xa7, 0x4e, 0x25,
	0x08, 0xeb, 0xde, 0x7e,
	0x80, 0xeb, 0x08, 0x7a,
	0xff, 0x6a, 0xd6, 0x09,
	0x08, 0xeb, 0x0c, 0x6a,
	0xff, 0x6a, 0xd4, 0x0c,
	0x80, 0xa3, 0xde, 0x6e,
	0x88, 0xeb, 0x22, 0x72,
	0x08, 0xeb, 0xde, 0x6e,
	0x04, 0xea, 0x26, 0xe2,
	0x08, 0xee, 0xde, 0x6e,
	0x04, 0x6a, 0xd0, 0x81,
	0x05, 0xa4, 0xc0, 0x89,
	0x03, 0xa5, 0xc2, 0x31,
	0x09, 0x6a, 0xd6, 0x05,
	0x00, 0x65, 0x0a, 0x5a,
	0x06, 0xa4, 0xd4, 0x89,
	0x80, 0x94, 0xde, 0x7e,
	0x07, 0xe9, 0x10, 0x31,
	0x01, 0xe9, 0x46, 0x31,
	0x00, 0xa3, 0xbc, 0x5e,
	0x00, 0x65, 0xfc, 0x59,
	0x01, 0xa4, 0xca, 0x30,
	0x80, 0xa3, 0x36, 0x7a,
	0x02, 0x65, 0xca, 0x00,
	0x01, 0x65, 0xf8, 0x31,
	0x80, 0x93, 0x26, 0x01,
	0xff, 0x6a, 0xd4, 0x0c,
	0x01, 0x8c, 0xc8, 0x30,
	0x00, 0x88, 0xc8, 0x18,
	0x02, 0x64, 0xc8, 0x88,
	0xff, 0x64, 0xde, 0x7e,
	0xff, 0x8d, 0x4c, 0x6a,
	0xff, 0x8e, 0x4c, 0x6a,
	0x03, 0x8c, 0xd4, 0x98,
	0x00, 0x65, 0xde, 0x56,
	0x01, 0x64, 0x70, 0x30,
	0xff, 0x64, 0xc8, 0x10,
	0x01, 0x64, 0xc8, 0x18,
	0x00, 0x8c, 0x18, 0x19,
	0xff, 0x8d, 0x1a, 0x21,
	0xff, 0x8e, 0x1c, 0x25,
	0xc0, 0x3c, 0x5c, 0x7a,
	0x21, 0x6a, 0xda, 0x5e,
	0xa8, 0x6a, 0x76, 0x00,
	0x79, 0x6a, 0x76, 0x00,
	0x40, 0x3f, 0x64, 0x6a,
	0x04, 0x3b, 0x76, 0x00,
	0x04, 0x6a, 0xd4, 0x81,
	0x20, 0x3c, 0x6c, 0x7a,
	0x51, 0x6a, 0xda, 0x5e,
	0x00, 0x65, 0x84, 0x42,
	0x20, 0x3c, 0x78, 0x00,
	0x00, 0xb3, 0xbc, 0x5e,
	0x07, 0xac, 0x10, 0x31,
	0x05, 0xb3, 0x46, 0x31,
	0x88, 0x6a, 0xcc, 0x00,
	0xac, 0x6a, 0xf0, 0x5d,
	0xa3, 0x6a, 0xcc, 0x00,
	0xb3, 0x6a, 0xf4, 0x5d,
	0x00, 0x65, 0x3c, 0x5a,
	0xfd, 0xa4, 0x48, 0x09,
	0x03, 0x8c, 0x10, 0x30,
	0x00, 0x65, 0xe8, 0x5d,
	0x01, 0xa4, 0x96, 0x7a,
	0x04, 0x3b, 0x76, 0x08,
	0x01, 0x3b, 0x26, 0x31,
	0x80, 0x02, 0x04, 0x00,
	0x10, 0x0c, 0x8c, 0x7a,
	0x03, 0x9e, 0x8e, 0x6a,
	0x7f, 0x02, 0x04, 0x08,
	0x91, 0x6a, 0xda, 0x5e,
	0x00, 0x65, 0xcc, 0x41,
	0x01, 0xa4, 0xca, 0x30,
	0x80, 0xa3, 0x9c, 0x7a,
	0x02, 0x65, 0xca, 0x00,
	0x01, 0x65, 0xf8, 0x31,
	0x01, 0x3b, 0x26, 0x31,
	0x00, 0x65, 0x10, 0x5a,
	0x01, 0xfc, 0xaa, 0x6a,
	0x80, 0x0b, 0xa0, 0x6a,
	0x10, 0x0c, 0xa0, 0x7a,
	0x20, 0x93, 0xa0, 0x6a,
	0x02, 0x93, 0x26, 0x01,
	0x02, 0xfc, 0xb4, 0x7a,
	0x40, 0x0d, 0xc8, 0x6a,
	0x01, 0xa4, 0x48, 0x01,
	0x00, 0x65, 0xc8, 0x42,
	0x40, 0x0d, 0xba, 0x6a,
	0x00, 0x65, 0x10, 0x5a,
	0x00, 0x65, 0xac, 0x42,
	0x80, 0xfc, 0xc4, 0x7a,
	0x80, 0xa4, 0xc4, 0x6a,
	0xff, 0xa5, 0x4a, 0x19,
	0xff, 0xa6, 0x4c, 0x21,
	0xff, 0xa7, 0x4e, 0x21,
	0xf8, 0xfc, 0x48, 0x09,
	0x7f, 0xa3, 0x46, 0x09,
	0x04, 0x3b, 0xe4, 0x6a,
	0x02, 0x93, 0x26, 0x01,
	0x01, 0x94, 0xca, 0x7a,
	0x01, 0x94, 0xca, 0x7a,
	0x01, 0x94, 0xca, 0x7a,
	0x01, 0x94, 0xca, 0x7a,
	0x01, 0x94, 0xca, 0x7a,
	0x01, 0xa4, 0xe2, 0x7a,
	0x01, 0xfc, 0xd8, 0x7a,
	0x01, 0x94, 0xe4, 0x6a,
	0x01, 0x94, 0xe4, 0x6a,
	0x01, 0x94, 0xe4, 0x6a,
	0x00, 0x65, 0x84, 0x42,
	0x01, 0x94, 0xe2, 0x7a,
	0x10, 0x94, 0xe4, 0x6a,
	0xd7, 0x93, 0x26, 0x09,
	0x28, 0x93, 0xe8, 0x6a,
	0x01, 0x85, 0x0a, 0x01,
	0x02, 0xfc, 0xf0, 0x6a,
	0x01, 0x14, 0x46, 0x31,
	0xff, 0x6a, 0x10, 0x09,
	0xfe, 0x85, 0x0a, 0x09,
	0xff, 0x38, 0xfe, 0x6a,
	0x80, 0xa3, 0xfe, 0x7a,
	0x80, 0x0b, 0xfc, 0x7a,
	0x04, 0x3b, 0xfe, 0x7a,
	0xbf, 0x3b, 0x76, 0x08,
	0x01, 0x3b, 0x26, 0x31,
	0x00, 0x65, 0x10, 0x5a,
	0x01, 0x0b, 0x0c, 0x6b,
	0x10, 0x0c, 0x00, 0x7b,
	0x04, 0x93, 0x0a, 0x6b,
	0x01, 0x94, 0x08, 0x7b,
	0x10, 0x94, 0x0a, 0x6b,
	0xc7, 0x93, 0x26, 0x09,
	0x01, 0x99, 0xd4, 0x30,
	0x38, 0x93, 0x0e, 0x6b,
	0xff, 0x08, 0x5c, 0x6b,
	0xff, 0x09, 0x5c, 0x6b,
	0xff, 0x0a, 0x5c, 0x6b,
	0xff, 0x38, 0x2a, 0x7b,
	0x04, 0x14, 0x10, 0x31,
	0x01, 0x38, 0x18, 0x31,
	0x02, 0x6a, 0x1a, 0x31,
	0x88, 0x6a, 0xcc, 0x00,
	0x14, 0x6a, 0xf6, 0x5d,
	0x00, 0x38, 0xe2, 0x5d,
	0xff, 0x6a, 0x70, 0x08,
	0x00, 0x65, 0x56, 0x43,
	0x80, 0xa3, 0x30, 0x7b,
	0x01, 0xa4, 0x48, 0x01,
	0x00, 0x65, 0x5c, 0x43,
	0x08, 0xeb, 0x36, 0x7b,
	0x00, 0x65, 0x10, 0x5a,
	0x08, 0xeb, 0x32, 0x6b,
	0x07, 0xe9, 0x10, 0x31,
	0x01, 0xe9, 0xca, 0x30,
	0x01, 0x65, 0x46, 0x31,
	0x00, 0x6a, 0xbc, 0x5e,
	0x88, 0x6a, 0xcc, 0x00,
	0xa4, 0x6a, 0xf6, 0x5d,
	0x08, 0x6a, 0xe2, 0x5d,
	0x0d, 0x93, 0x26, 0x01,
	0x00, 0x65, 0xaa, 0x5e,
	0x88, 0x6a, 0xcc, 0x00,
	0x00, 0x65, 0x8c, 0x5e,
	0x01, 0x99, 0x46, 0x31,
	0x00, 0xa3, 0xbc, 0x5e,
	0x01, 0x88, 0x10, 0x31,
	0x00, 0x65, 0x3c, 0x5a,
	0x00, 0x65, 0xfc, 0x59,
	0x03, 0x8c, 0x10, 0x30,
	0x00, 0x65, 0xe8, 0x5d,
	0x80, 0x0b, 0x84, 0x6a,
	0x80, 0x0b, 0x64, 0x6b,
	0x01, 0x0c, 0x5e, 0x7b,
	0x10, 0x0c, 0x84, 0x7a,
	0x03, 0x9e, 0x84, 0x6a,
	0x00, 0x65, 0x06, 0x5a,
	0x00, 0x6a, 0xbc, 0x5e,
	0x01, 0xa4, 0x84, 0x6b,
	0xff, 0x38, 0x7a, 0x7b,
	0x01, 0x38, 0xc8, 0x30,
	0x00, 0x08, 0x40, 0x19,
	0xff, 0x6a, 0xc8, 0x08,
	0x00, 0x09, 0x42, 0x21,
	0x00, 0x0a, 0x44, 0x21,
	0xff, 0x6a, 0x70, 0x08,
	0x00, 0x65, 0x7c, 0x43,
	0x03, 0x08, 0x40, 0x31,
	0x03, 0x08, 0x40, 0x31,
	0x01, 0x08, 0x40, 0x31,
	0x01, 0x09, 0x42, 0x31,
	0x01, 0x0a, 0x44, 0x31,
	0xfd, 0xb4, 0x68, 0x09,
	0x12, 0x01, 0x02, 0x00,
	0x12, 0x01, 0x02, 0x00,
	0x04, 0x3c, 0xcc, 0x79,
	0xfb, 0x3c, 0x78, 0x08,
	0x04, 0x93, 0x20, 0x79,
	0x01, 0x0c, 0x90, 0x6b,
	0x80, 0xba, 0x20, 0x79,
	0x80, 0x04, 0x20, 0x79,
	0xe4, 0x6a, 0x70, 0x5d,
	0x23, 0x6a, 0x86, 0x5d,
	0x01, 0x6a, 0x86, 0x5d,
	0x00, 0x65, 0x20, 0x41,
	0x00, 0x65, 0xcc, 0x41,
	0x80, 0x3c, 0xa4, 0x7b,
	0x21, 0x6a, 0xda, 0x5e,
	0x01, 0xbc, 0x18, 0x31,
	0x02, 0x6a, 0x1a, 0x31,
	0x02, 0x6a, 0xf8, 0x01,
	0x01, 0xbc, 0x10, 0x30,
	0x02, 0x6a, 0x12, 0x30,
	0x01, 0xbc, 0x10, 0x30,
	0xff, 0x6a, 0x12, 0x08,
	0xff, 0x6a, 0x14, 0x08,
	0xf3, 0xbc, 0xd4, 0x18,
	0xa0, 0x6a, 0xca, 0x53,
	0x04, 0xa0, 0x10, 0x31,
	0xac, 0x6a, 0x26, 0x01,
	0x04, 0xa0, 0x10, 0x31,
	0x03, 0x08, 0x18, 0x31,
	0x88, 0x6a, 0xcc, 0x00,
	0xa0, 0x6a, 0xf6, 0x5d,
	0x00, 0xbc, 0xe2, 0x5d,
	0x3d, 0x6a, 0x26, 0x01,
	0x00, 0x65, 0xe2, 0x43,
	0xff, 0x6a, 0x10, 0x09,
	0xa4, 0x6a, 0x26, 0x01,
	0x0c, 0xa0, 0x32, 0x31,
	0x05, 0x6a, 0x26, 0x01,
	0x35, 0x6a, 0x26, 0x01,
	0x0c, 0xa0, 0x32, 0x31,
	0x36, 0x6a, 0x26, 0x01,
	0x02, 0x93, 0x26, 0x01,
	0x35, 0x6a, 0x26, 0x01,
	0x00, 0x65, 0x9e, 0x5e,
	0x00, 0x65, 0x9e, 0x5e,
	0x02, 0x93, 0x26, 0x01,
	0xbf, 0x3c, 0x78, 0x08,
	0x04, 0x0b, 0xe8, 0x6b,
	0x10, 0x0c, 0xe4, 0x7b,
	0x01, 0x03, 0xe8, 0x6b,
	0x20, 0x93, 0xea, 0x6b,
	0x04, 0x0b, 0xf0, 0x6b,
	0x40, 0x3c, 0x78, 0x00,
	0xc7, 0x93, 0x26, 0x09,
	0x38, 0x93, 0xf2, 0x6b,
	0x00, 0x65, 0xcc, 0x41,
	0x80, 0x3c, 0x58, 0x6c,
	0x01, 0x06, 0x50, 0x31,
	0x80, 0xb8, 0x70, 0x01,
	0x00, 0x65, 0xcc, 0x41,
	0x10, 0x3f, 0x06, 0x00,
	0x10, 0x6a, 0x06, 0x00,
	0x01, 0x3a, 0xca, 0x30,
	0x80, 0x65, 0x1e, 0x64,
	0x10, 0xb8, 0x42, 0x6c,
	0xc0, 0x3e, 0xca, 0x00,
	0x40, 0xb8, 0x0e, 0x6c,
	0xbf, 0x65, 0xca, 0x08,
	0x20, 0xb8, 0x22, 0x7c,
	0x01, 0x65, 0x0c, 0x30,
	0x00, 0x65, 0xda, 0x5d,
	0xa0, 0x3f, 0x2a, 0x64,
	0x23, 0xb8, 0x0c, 0x08,
	0x00, 0x65, 0xda, 0x5d,
	0xa0, 0x3f, 0x2a, 0x64,
	0x00, 0xbb, 0x22, 0x44,
	0xff, 0x65, 0x22, 0x64,
	0x00, 0x65, 0x42, 0x44,
	0x40, 0x6a, 0x18, 0x00,
	0x01, 0x65, 0x0c, 0x30,
	0x00, 0x65, 0xda, 0x5d,
	0xa0, 0x3f, 0xfe, 0x73,
	0x40, 0x6a, 0x18, 0x00,
	0x01, 0x3a, 0xa6, 0x30,
	0x08, 0x6a, 0x74, 0x00,
	0x00, 0x65, 0xcc, 0x41,
	0x64, 0x6a, 0x6a, 0x5d,
	0x80, 0x64, 0xda, 0x6c,
	0x04, 0x64, 0x9c, 0x74,
	0x02, 0x64, 0xac, 0x74,
	0x00, 0x6a, 0x62, 0x74,
	0x03, 0x64, 0xca, 0x74,
	0x23, 0x64, 0x4a, 0x74,
	0x08, 0x64, 0x5e, 0x74,
	0x61, 0x6a, 0xda, 0x5e,
	0x00, 0x65, 0xda, 0x5d,
	0x08, 0x51, 0xce, 0x71,
	0x00, 0x65, 0x42, 0x44,
	0x80, 0x04, 0x5c, 0x7c,
	0x51, 0x6a, 0x60, 0x5d,
	0x01, 0x51, 0x5c, 0x64,
	0x01, 0xa4, 0x54, 0x7c,
	0x80, 0xba, 0x5e, 0x6c,
	0x41, 0x6a, 0xda, 0x5e,
	0x00, 0x65, 0x5e, 0x44,
	0x21, 0x6a, 0xda, 0x5e,
	0x00, 0x65, 0x5e, 0x44,
	0x07, 0x6a, 0x56, 0x5d,
	0x01, 0x06, 0xd4, 0x30,
	0x00, 0x65, 0xcc, 0x41,
	0x80, 0xb8, 0x58, 0x7c,
	0xc0, 0x3c, 0x6c, 0x7c,
	0x80, 0x3c, 0x58, 0x6c,
	0xff, 0xa8, 0x6c, 0x6c,
	0x40, 0x3c, 0x58, 0x6c,
	0x10, 0xb8, 0x70, 0x7c,
	0xa1, 0x6a, 0xda, 0x5e,
	0x01, 0xb4, 0x76, 0x6c,
	0x02, 0xb4, 0x78, 0x6c,
	0x01, 0xa4, 0x78, 0x7c,
	0xff, 0xa8, 0x88, 0x7c,
	0x04, 0xb4, 0x68, 0x01,
	0x01, 0x6a, 0x76, 0x00,
	0x00, 0xbb, 0x14, 0x5e,
	0xff, 0xa8, 0x88, 0x7c,
	0x71, 0x6a, 0xda, 0x5e,
	0x40, 0x51, 0x88, 0x64,
	0x00, 0x65, 0xb4, 0x5e,
	0x00, 0x65, 0xde, 0x41,
	0x00, 0xbb, 0x8c, 0x5c,
	0x00, 0x65, 0xde, 0x41,
	0x00, 0x65, 0xb4, 0x5e,
	0x01, 0x65, 0xa2, 0x30,
	0x01, 0xf8, 0xc8, 0x30,
	0x01, 0x4e, 0xc8, 0x30,
	0x00, 0x6a, 0xb8, 0xdd,
	0x00, 0x51, 0xca, 0x5d,
	0x01, 0x4e, 0x9c, 0x18,
	0x02, 0x6a, 0x22, 0x05,
	0xc0, 0x3c, 0x58, 0x6c,
	0x04, 0xb8, 0x70, 0x01,
	0x00, 0x65, 0xd6, 0x5e,
	0x20, 0xb8, 0xde, 0x69,
	0x01, 0xbb, 0xa2, 0x30,
	0x3f, 0xba, 0x7c, 0x08,
	0x00, 0xb9, 0xd0, 0x5c,
	0x00, 0x65, 0xde, 0x41,
	0x01, 0x06, 0xd4, 0x30,
	0x20, 0x3c, 0xcc, 0x79,
	0x20, 0x3c, 0x5e, 0x7c,
	0x01, 0xa4, 0xba, 0x7c,
	0x01, 0xb4, 0x68, 0x01,
	0x00, 0x65, 0xcc, 0x41,
	0x00, 0x65, 0x5e, 0x44,
	0x04, 0x14, 0x58, 0x31,
	0x01, 0x06, 0xd4, 0x30,
	0x08, 0xa0, 0x60, 0x31,
	0xac, 0x6a, 0xcc, 0x00,
	0x14, 0x6a, 0xf6, 0x5d,
	0x01, 0x06, 0xd4, 0x30,
	0xa0, 0x6a, 0xee, 0x5d,
	0x00, 0x65, 0xcc, 0x41,
	0xdf, 0x3c, 0x78, 0x08,
	0x12, 0x01, 0x02, 0x00,
	0x00, 0x65, 0x5e, 0x44,
	0x4c, 0x65, 0xcc, 0x28,
	0x01, 0x3e, 0x20, 0x31,
	0xd0, 0x66, 0xcc, 0x18,
	0x20, 0x66, 0xcc, 0x18,
	0x01, 0x51, 0xda, 0x34,
	0x4c, 0x3d, 0xca, 0x28,
	0x3f, 0x64, 0x7c, 0x08,
	0xd0, 0x65, 0xca, 0x18,
	0x01, 0x3e, 0x20, 0x31,
	0x30, 0x65, 0xd4, 0x18,
	0x00, 0x65, 0xe8, 0x4c,
	0xe1, 0x6a, 0x22, 0x01,
	0xff, 0x6a, 0xd4, 0x08,
	0x20, 0x65, 0xd4, 0x18,
	0x00, 0x65, 0xf0, 0x54,
	0xe1, 0x6a, 0x22, 0x01,
	0xff, 0x6a, 0xd4, 0x08,
	0x20, 0x65, 0xca, 0x18,
	0xe0, 0x65, 0xd4, 0x18,
	0x00, 0x65, 0xfa, 0x4c,
	0xe1, 0x6a, 0x22, 0x01,
	0xff, 0x6a, 0xd4, 0x08,
	0xd0, 0x65, 0xd4, 0x18,
	0x00, 0x65, 0x02, 0x55,
	0xe1, 0x6a, 0x22, 0x01,
	0xff, 0x6a, 0xd4, 0x08,
	0x01, 0x6c, 0xa2, 0x30,
	0xff, 0x51, 0x14, 0x75,
	0x00, 0x51, 0x90, 0x5d,
	0x01, 0x51, 0x20, 0x31,al channel ID.
diff --git a/drivers/mxc/ipu3/Makefile b/drivers/mxc/ipu3/Makefile
index 2d9bc3c..aa3e7b1 100644
--- a/drivers/mxc/ipu3/Makefile
+++ b/drivers/mxc/ipu3/Makefile
@@ -1,3 +1,4 @@
 obj-$(CONFIG_MXC_IPU_V3) = mxc_ipu.o
 
-mxc_ipu-objs := ipu_common.o ipu_ic.o ipu_disp.o ipu_capture.o ipu_device.o
+mxc_ipu-objs := ipu_common.o ipu_ic.o ipu_disp.o ipu_capture.o ipu_device.o ipu_calc_stripes_sizes.o
+
diff --git a/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c b/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c
new file mode 100644
index 0000000..09c7664
--- /dev/null
+++ b/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c
@@ -0,0 +1,374 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * @file ipu_calc_stripes_sizes.c
+ *
+ * @brief IPU IC functions
+ *
+ * @ingroup IPU
+ */
+
+#include <linux/module.h>
+#include <linux/ipu.h>
+#include <asm/div64.h>
+
+#define BPP_32 0
+#define BPP_16 3
+#define BPP_8 5
+#define BPP_24 1
+#define BPP_12 4
+#define BPP_18 2
+
+static u64 _do_div(u64 a, u32 b)
+{
+	u64 div;
+	div = a;
+	do_div(div, b);
+	return div;
+}
+
+static u32 truncate(u32 up, /* 0: down; else: up */
+					u64 a, /* must be non-negative */
+					u32 b)
+{
+	u32 d;
+	u64 div;
+	div = _do_div(a, b);
+	d = b * (div >> 32);
+	if (up && (a > (((u64)d) << 32)))
+		return d+b;
+	else
+		return d;
+}
+
+static unsigned int f_calc(unsigned int pfs, unsigned int bpp, unsigned int *write)
+{/* return input_f */
+	unsigned int f_calculated = 0;
+	switch (pfs) {
+	case IPU_PIX_FMT_YVU422P:
+	case IPU_PIX_FMT_YUV422P:
+	case IPU_PIX_FMT_YUV420P2:
+	case IPU_PIX_FMT_YUV420P:
+		f_calculated = 16;
+		break;
+
+	case IPU_PIX_FMT_NV12:
+		f_calculated = 8;
+		break;
+
+	default:
+		f_calculated = 0;
+		break;
+
+	}
+	if (!f_calculated) {
+		switch (bpp) {
+		case BPP_32:
+			f_calculated = 2;
+			break;
+
+		case BPP_16:
+			f_calculated = 4;
+			break;
+
+		case BPP_8:
+		case BPP_24:
+			f_calculated = 8;
+			break;
+
+		case BPP_12:
+			f_calculated = 16;
+			break;
+
+		case BPP_18:
+			f_calculated = 32;
+			break;
+
+		default:
+			f_calculated = 0;
+			break;
+			}
+		}
+	return f_calculated;
+}
+
+
+static unsigned int m_calc(unsigned int pfs)
+{
+	unsigned int m_calculated = 0;
+	switch (pfs) {
+	case IPU_PIX_FMT_YUV420P2:
+	case IPU_PIX_FMT_YUV420P:
+	case IPU_PIX_FMT_YVU422P:
+	case IPU_PIX_FMT_YUV422P:
+	case IPU_PIX_FMT_YVU420P:
+	case IPU_PIX_FMT_NV12:
+		m_calculated = 8;
+		break;
+
+	case IPU_PIX_FMT_YUYV:
+	case IPU_PIX_FMT_UYVY:
+		m_calculated = 2;
+		break;
+
+	default:
+		m_calculated = 1;
+		break;
+
+	}
+	return m_calculated;
+}
+
+
+/* Stripe parameters calculator */
+/**************************************************************************
+Notes:
+MSW = the maximal width allowed for a stripe
+	i.MX31: 720, i.MX35: 800, i.MX37/51/53: 1024
+cirr = the maximal inverse resizing ratio for which overlap in the input
+	is requested; typically cirr~2
+equal_stripes:
+	0: each stripe is allowed to have independent parameters
+		for maximal image quality
+	1: the stripes are requested to have identical parameters
+	(except the base address), for maximal performance
+If performance is the top priority (above image quality)
+	Avoid overlap, by setting CIRR = 0
+		This will also force effectively identical_stripes = 1
+	Choose IF & OF that corresponds to the same IOX/SX for both stripes
+	Choose IFW & OFW such that
+	IFW/IM, IFW/IF, OFW/OM, OFW/OF are even integers
+	The function returns an error status:
+	0: no error
+	1: invalid input parameters -> aborted without result
+		Valid parameters should satisfy the following conditions
+		IFW <= OFW, otherwise downsizing is required
+					 - which is not supported yet
+		4 <= IFW,OFW, so some interpolation may be needed even without overlap
+		IM,x18,
	0x00, 0x65, 0x9a, 0x5e,
	0x00, 0x65, 0x54, 0x66,
	0x0a, 0x93, 0x26, 0x01,
	0x00, 0x65, 0xaa, 0x46,
	0xa0, 0x6a, 0xcc, 0x00,
	0xff, 0x6a, 0xc8, 0x08,
	0x20, 0x94, 0x60, 0x6e,
	0x10, 0x94, 0x62, 0x6e,
	0x08, 0x94, 0x7c, 0x6e,
	0x08, 0x94, 0x7c, 0x6e,
	0x08, 0x94, 0x7c, 0x6e,
	0xff, 0x8c, 0xc8, 0x10,
	0xc1, 0x64, 0xc8, 0x18,
	0xf8, 0x64, 0xc8, 0x08,
	0x01, 0x99, 0xda, 0x30,
	0x00, 0x66, 0x70, 0x66,
	0xc0, 0x66, 0xac, 0x76,
	0x60, 0x66, 0xc8, 0x18,
	0x3d, 0x64, 0xc8, 0x28,
	0x00, 0x65, 0x60, 0x46,
	0xf7, 0x93, 0x26, 0x09,
	0x08, 0x93, 0x7e, 0x6e,
	0x00, 0x62, 0xc4, 0x18,
	0x00, 0x65, 0xaa, 0x5e,
	0x00, 0x65, 0x8a, 0x5e,
	0x00, 0x65, 0x8a, 0x5e,
	0x00, 0x65, 0x8a, 0x5e,
	0x01, 0x99, 0xda, 0x30,
	0x01, 0x99, 0xda, 0x30,
	0x01, 0x99, 0xda, 0x30,
	0x01, 0x99, 0xda, 0x30,
	0x01, 0x99, 0xda, 0x30,
	0x01, 0x99, 0xda, 0x30,
	0x01, 0x99, 0xda, 0x30,
	0x01, 0x99, 0xda, 0x34,
	0x01, 0x6c, 0x32, 0x31,
	0x01, 0x6c, 0x32, 0x31,
	0x01, 0x6c, 0x32, 0x31,
	0x01, 0x6c, 0x32, 0x31,
	0x01, 0x6c, 0x32, 0x31,
	0x01, 0x6c, 0x32, 0x31,
	0x01, 0x6c, 0x32, 0x31,
	0x01, 0x6c, 0x32, 0x35,
	0x08, 0x94, 0xaa, 0x7e,
	0xf7, 0x93, 0x26, 0x09,
	0x08, 0x93, 0xae, 0x6e,
	0xff, 0x6a, 0xd4, 0x0c,
	0x04, 0xb8, 0xd6, 0x6e,
	0x01, 0x42, 0x7e, 0x31,
	0xff, 0x6a, 0x76, 0x01,
	0x01, 0x90, 0x84, 0x34,
	0xff, 0x6a, 0x76, 0x05,
	0x01, 0x85, 0x0a, 0x01,
	0x7f, 0x65, 0x10, 0x09,
	0xfe, 0x85, 0x0a, 0x0d,
	0xff, 0x42, 0xd2, 0x66,
	0xff, 0x41, 0xca, 0x66,
	0xd1, 0x6a, 0xda, 0x5e,
	0xff, 0x6a, 0xca, 0x04,
	0x01, 0x41, 0x20, 0x31,
	0x01, 0xbf, 0x82, 0x30,
	0x01, 0x6a, 0x76, 0x00,
	0x00, 0xbb, 0x14, 0x46,
	0x01, 0x42, 0x20, 0x31,
	0x01, 0xbf, 0x84, 0x34,
	0x01, 0x41, 0x7e, 0x31,
	0x01, 0x90, 0x82, 0x34,
	0x01, 0x65, 0x22, 0x31,
	0xff, 0x6a, 0xd4, 0x08,
	0xff, 0x6a, 0xd4, 0x0c
};

typedef int ahc_patch_func_t (struct ahc_softc *ahc);
static ahc_patch_func_t ahc_patch23_func;

static int
ahc_patch23_func(struct ahc_softc *ahc)
{
	return ((ahc->bugs & AHC_SCBCHAN_UPLOAD_BUG) != 0);
}

static ahc_patch_func_t ahc_patch22_func;

static int
ahc_patch22_func(struct ahc_softc *ahc)
{
	return ((ahc->features & AHC_CMD_CHAN) == 0);
}

static ahc_patch_func_t ahc_patch21_func;

static int
ahc_patch21_func(struct ahc_softc *ahc)
{
	return ((ahc->features & AHC_QUEUE_REGS) == 0);
}

static ahc_patch_func_t ahc_patch20_func;

static int
ahc_patch20_func(struct ahc_softc *ahc)
{
	return ((ahc->features & AHC_WIDE) != 0);
}

static ahc_patch_func_t ahc_patch19_func;

static int
ahc_patch19_func(struct ahc_softc *ahc)
{
	return ((ahc->flags & AHC_SCB_BTT) != 0);
}

static ahc_patch_func_t ahc_patch18_func;

static int
ahc_patch18_func(struct ahc_softc *ahc)
{
	return ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0);
}

static ahc_patch_func_t ahc_patch17_func;

static int
ahc_patch17_func(struct ahc_softc *ahc)
{
	return ((ahc->bugs & AHC_TMODE_WIDEODD_BUG) != 0);
}

static ahc_patch_func_t ahc_patch16_func;

static int
ahc_patch16_func(struct ahc_softc *ahc)
{
	return ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0);
}

static ahc_patch_func_t ahc_patch15_func;

static int
ahc_patch15_func(struct ahc_softc *ahc)
{
	return ((ahc->features & AHC_ULTRA2) == 0);
}

static ahc_patch_func_t ahc_patch14_func;

static int
ahc_patch14_func(struct ahc_softc *ahc)
{
	return ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0);
}

static ahc_patch_func_t ahc_patch13_func;

static int
ahc_patch13_func(struct ahc_softc *ahc)
{
	return ((ahc->flags & AHC_39BIT_ADDRESSING) != 0);
}

static ahc_patch_func_t ahc_patch12_func;

static int
ahc_patch12_func(struct ahc_softc *ahc)
{
	return ((ahc->features & AHC_HS_MAILBOX) != 0);
}

static ahc_patch_func_t ahc_patch11_func;

static int
ahc_patch11_func(struct ahc_softc *ahc)
{
	return ((ahc->features & AHC_ULTRA) != 0);
}

static ahc_patch_func_t ahc_patch10_func;

static int
ahc_patch10_func(struct ahc_softc *ahc)
{
	return ((ahc->features & AHC_MULTI_TID) != 0);
}

static ahc_patch_func_t ahc_patch9_func;

static int
ahc_patch9_func(struct ahc_softc *ahc)
{
	return ((ahc->features & AHC_CMD_CHAN) != 0);
}

static ahc_patch_func_t ahc_patch8_func;

static int
ahc_patch8_func(struct ahc_softc *ahc)
{
	return ((ahc->flags & AHC_INITIATORROLE) != 0);
}

static ahc_patch_func_t ahc_patch7_func;

static int
ahc_patch7_func(struct ahc_softc *ahc)
{
	return ((ahc->flags & AHC_TARGETROLE) != 0);
}

static ahc_patch_func_t ahc_patch6_func;

static int
ahc_patch6_func(struct ahc_softc *ahc)
{
	return ((ahc->features & AHC_DT) == 0);
}

static ahc_patch_func_t ahc_patch5_func;

static int
ahc_patch5_func(struct ahc_softc *ahc)
{
	return ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0);
}

static ahc_patch_func_t ahc_patch4_func;

static int
ahc_patch4_func(struct ahc_softc *ahc)
{
	return ((ahc->flags & AHC_PAGESCBS) != 0);
}

static ahc_patch_func_t ahc_patch3_func;

static int
ahc_patch3_func(struct ahc_softc *ahc)
{
	return ((ahc->features & AHC_QUEUE_REGS) != 0);
}

static ahc_patch_func_t ahc_patch2_func;

static int
ahc_patch2_func(struct ahc_softc *ahc)
{
	return ((ahc->features & AHC_TWIN) != 0);
}

static ahc_patch_func_t ahc_patch1_func;

static int
ahc_patch1_func(struct ahc_softc *ahc)
{
	return ((ahc->features & AHC_ULTRA2) != 0);
}

static ahc_patch_func_t ahc_patch0_func;

static int
ahc_patch0_func(struct ahc_softc *ahc)
{
	return (0);
}

static const struct patch {
	ahc_patch_func_t		*patch_func;
	uint32_t		 begin		:10,
				 skip_instr	:10,
				 skip_patch	:12;
} patches[] = {
	{ ahc_patch1_func, 4, 1, 1 },
	{ ahc_patch2_func, 6, 2, 1 },
	{ ahc_patch2_func, 9, 1, 1 },
	{ ahc_patch3_func, 11, 1, 2 },
	{ ahc_patch0_func, 12, 2, 1 },
	{ ahc_patch4_func, 15, 1, 2 },
	{ ahc_patch0_func, 16, 1, 1 },
	{ ahc_patch5_func, 22, 2, 1 },
	{ ahc_patch3_func, 27, 1, 2 },
	{ ahc_patch0_func, 28, 1, 1 },
	{ ahc_patch6_func, 34, 1, 1 },
	{ ahc_patch7_func, 37, 54, 19 },
	{ ahc_patch8_func, 37, 1, 1 },
	{ ahc_patch9_func, 42, 3, 2 },
	{ ahc_patch0_func, 45, 3, 1 },
	{ ahc_patch10_func, 49, 1, 2 },
	{ ahc_patch0_func, 50, 2, 3 },
	{ ahc_patch1_func, 50, 1, 2 },
	{ ahc_patch0_func, 51, 1, 1 },
	{ ahc_patch2_func, 53, 2, 1 },
	{ ahc_patch9_func, 55, 1, 2 },
	{ ahc_patch0_func, 56, 1, 1 },
	{ ahc_patch9_func, 60, 1, 2 },
	{ ahc_patch0_func, 61, 1, 1 },
	{ ahc_patch9_func, 71, 1, 2 },
	{ ahc_patch0_func, 72, 1, 1 },
	{ ahc_patch9_func, 75, 1, 2 },
	{ ahc_patch0_func, 76, 1, 1 },
	{ ahc_patch9_func, 79, 1, 2 },
	{ ahc_patch0_func, 80, 1, 1 },
	{ ahc_patch8_func, 91, 9, 4 },
	{ ahc_patch1_func, 93, 1, 2 },
	{ ahc_patch0_func, 94, 1, 1 },
	{ ahc_patch2_func, 96, 2, 1 },
	{ ahc_patch2_func, 105, 4, 1 },
	{ ahc_patch1_func, 109, 1, 2 },
	{ ahc_patch0_func, 110, 2, 3 },
	{ ahc_patch2_func, 110, 1, 2 },
	{ ahc_patch0_func, 111, 1, 1 },
	{ ahc_patch7_func, 112, 4, 2 },
	{ ahc_patch0_func, 116, 1, 1 },
	{ ahc_patch11_func, 117, 2, 1 },
	{ ahc_patch1_func, 119, 1, 2 },
	{ ahc_patch0_func, 120, 1, 1 },
	{ ahc_patch7_func, 121, 4, 1 },
	{ ahc_patch7_func, 131, 95, 11 },
	{ ahc_patch4_func, 151, 1, 1 },
	{ ahc_patch1_func, 168, 1, 1 },
	{ ahc_patch12_func, 173, 1, 2 },
	{ ahc_patch0_func, 174, 1, 1 },
	{ ahc_patch9_func, 185, 1, 2 },
	{ ahc_patch0_func, 186, 1, 1 },
	{ ahc_patch9_func, 195, 1, 2 },
	{ ahc_patch0_func, 196, 1, 1 },
	{ ahc_patch9_func, 212, 6, 2 },
	{ ahc_patch0_func, 218, 6, 1 },
	{ ahc_patch8_func, 226, 21, 2 },
	{ ahc_patch1_func, 241, 1, 1 },
	{ ahc_patch1_func, 249, 1, 2 },
	{ ahc_patch0_func, 250, 2, 2 },
	{ ahc_patch11_func, 251, 1, 1 },
	{ ahc_patch9_func, 259, 27, 3 },
	{ ahc_patch1_func, 275, 10, 2 },
	{ ahc_patch13_func, 278, 1, 1 },
	{ ahc_patch14_func, 286, 14, 1 },
	{ ahc_patch1_func, 302, 1, 2 },
	{ ahc_patch0_func, 303, 1, 1 },
	{ ahc_patch9_func, 306, 1, 1 },
	{ ahc_patch13_func, 311, 1, 1 },
	{ ahc_patch9_func, 312, 2, 2 },
	{ ahc_patch0_func, 314, 4, 1 },
	{ ahc_patch14_func, 318, 1, 1 },
	{ ahc_patch15_func, 320, 2, 3 },
	{ ahc_patch9_func, 320, 1, 2 },
	{ ahc_patch0_func, 321, 1, 1 },
	{ ahc_patch6_func, 326, 1, 2 },
	{ ahc_patch0_func, 327, 1, 1 },
	{ ahc_patch1_func, 331, 47, 11 },
	{ ahc_patch6_func, 338, 2, 4 },
	{ ahc_patch7_func, 338, 1, 1 },
	{ ahc_patch8_func, 339, 1, 1 },
	{ ahc_patch0_func, 340, 1, 1 },
	{ ahc_patch16_func, 341, 1, 1 },
	{ ahc_patch6_func, 357, 6, 3 },
	{ ahc_patch16_func, 357, 5, 1 },
	{ ahc_patch0_func, 363, 7, 1 },
	{ ahc_patch13_func, 373, 5, 1 },
	{ ahc_patch0_func, 378, 52, 17 },
	{ ahc_patch14_func, 378, 1, 1 },
	{ ahc_patch7_func, 380, 2, 2 },
	{ ahc_patch17_func, 381, 1, 1 },
	{ ahc_patch9_func, 384, 1, 1 },
	{ ahc_patch18_func, 391, 1, 1 },
	{ ahc_patch14_func, 396, 9, 3 },
	{ ahc_patch9_func, 397, 3, 2 },
	{ ahc_patch0_func, 400, 3, 1 },
	{ ahc_patch9_func, 408, 6, 2 },
	{ ahc_patch0_func, 414, 9, 2 },
	{ ahc_patch13_func, 414, 1, 1 },
	{ ahc_patch13_func, 423, 2, 1 },
	{ ahc_patch14_func, 425, 1, 1 },
	{ ahc_patch9_func, 427, 1, 2 },
	{ ahc_patch0_func, 428, 1, 1 },
	{ ahc_patch7_func, 429, 1, 1 },
	{ ahc_patch7_func, 430, 1, 1 },
	{ ahc_patch8_func, 431, 3, 3 },
	{ ahc_patch6_func, 432, 1, 2 },
	{ ahc_patch0_func, 433, 1, 1 },
	{ ahc_patch9_func, 434, 1, 1 },
	{ ahc_patch15_func, 435, 1, 2 },
	{ ahc_patch13_func, 435, 1, 1 },
	{ ahc_patch14_func, 437, 9, 4 },
	{ ahc_patch9_func, 437, 1, 1 },
	{ ahc_patch9_func, 444, 2, 1 },
	{ ahc_patch0_func, 446, 4, 3 },
	{ ahc_patch9_func, 446, 1, 2 },
	{ ahc_patch0_func, 447, 3, 1 },
	{ ahc_patch1_func, 451, 2, 1 },
	{ ahc_patch7_func, 453, 10, 2 },
	{ ahc_patch0_func, 463, 1, 1 },
	{ ahc_patch8_func, 464, 118, 22 },
	{ ahc_patch1_func, 466, 3, 2 },
	{ ahc_patch0_func, 469, 5, 3 },
	{ ahc_patch9_func, 469, 2, 2 },
	{ ahc_patch0_func, 471, 3, 1 },
	{ ahc_patch1_func, 476, 2, 2 },
	{ ahc_patch0_func, 478, 6, 3 },
	{ ahc_patch9_func, 478, 2, 2 },
	{ ahc_patch0_func, 480, 3, 1 },
	{ ahc_patch1_func, 486, 2, 2 },
	{ ahc_patch0_func, 488, 9, 7 },
	{ ahc_patch9_func, 488, 5, 6 },
	{ ahc_patch19_func, 488, 1, 2 },
	{ ahc_patch0_func, 489, 1, 1 },
	{ ahc_patch19_func, 491, 1, 2 },
	{ ahc_patch0_func, 492, 1, 1 },
	{ ahc_patch0_func, 493, 4, 1 },
	{ ahc_patch6_func, 498, 3, 2 },
	{ ahc_patch0_func, 501, 1, 1 },
	{ ahc_patch6_func, 511, 1, 2 },
	{ ahc_patch0_func, 512, 1, 1 },
	{ ahc_patch20_func, 549, 7, 1 },
	{ ahc_patch3_func, 584, 1, 2 },
	{ ahc_patch0_func, 585, 1, 1 },
	{ ahc_patch21_func, 588, 1, 1 },
	{ ahc_patch8_func, 590, 106, 33 },
	{ ahc_patch4_func, 592, 1, 1 },
	{ ahc_patch1_func, 598, 2, 2 },
	{ ahc_patch0_func, 600, 1, 1 },
	{ ahc_patch1_func, 603, 1, 2 },
	{ ahc_patch0_func, 604, 1, 1 },
	{ ahc_patch9_func, 605, 3, 3 },
	{ ahc_patch15_func, 606, 1, 1 },
	{ ahc_patch0_func, 608, 4, 1 },
	{ ahc_patch19_func, 617, 2, 2 },
	{ ahc_patch0_func, 619, 1, 1 },
	{ ahc_patch19_func, 623, 10, 3 },
	{ ahc_patch5_func, 625, 8, 1 },
	{ ahc_patch0_func, 633, 9, 2 },
	{ ahc_patch5_func, 634, 8, 1 },
	{ ahc_patch4_func, 644, 1, 2 },
	{ ahc_patch0_func, 645, 1, 1 },
	{ ahc_patch19_func, 646, 1, 2 },
	{ ahc_patch0_func, 647, 3, 2 },
	{ ahc_patch4_func, 649, 1, 1 },
	{ ahc_patch5_func, 650, 1, 1 },
	{ ahc_patch5_func, 653, 1, 1 },
	{ ahc_patch5_func, 655, 1, 1 },
	{ ahc_patch4_func, 657, 2, 2 },
	{ ahc_patch0_func, 659, 2, 1 },
	{ ahc_patch5_func, 661, 1, 1 },
	{ ahc_patch5_func, 664, 1, 1 },
	{ ahc_patch5_func, 667, 1, 1 },
	{ ahc_patch19_func, 671, 1, 1 },
	{ ahc_patch19_func, 674, 1, 1 },
	{ ahc_patch4_func, 680, 1, 1 },
	{ ahc_patch6_func, 683, 1, 2 },
	{ ahc_patch0_func, 684, 1, 1 },
	{ ahc_patch7_func, 696, 16, 1 },
	{ ahc_patch4_func, 712, 20, 1 },
	{ ahc_patch9_func, 733, 4, 2 },
	{ ahc_patch0_func, 737, 4, 1 },
	{ ahc_patch9_func, 741, 4, 2 },
	{ ahc_patch0_func, 745, 3, 1 },
	{ ahc_patch6_func, 751, 1, 1 },
	{ ahc_patch22_func, 753, 14, 1 },
	{ ahc_patch7_func, 767, 3, 1 },
	{ ahc_patch9_func, 779, 24, 8 },
	{ ahc_patch19_func, 783, 1, 2 },
	{ ahc_patch0_func, 784, 1, 1 },
	{ ahc_patch15_func, 789, 4, 2 },
	{ ahc_patch0_func, 793, 7, 3 },
	{ ahc_patch23_func, 793, 5, 2 },
	{ ahc_patch0_func, 798, 2, 1 },
	{ ahc_patch0_func, 803, 42, 3 },
	{ ahc_patch18_func, 815, 18, 2 },
	{ ahc_patch0_func, 833, 1, 1 },
	{ ahc_patch4_func, 857, 1, 1 },
	{ ahc_patch4_func, 858, 3, 2 },
	{ ahc_patch0_func, 861, 1, 1 },
	{ ahc_patch13_func, 862, 3, 1 },
	{ ahc_patch4_func, 865, 12, 1 }
};

static const struct cs {
	uint16_t	begin;
	uint16_t	end;
} critical_sections[] = {
	{ 11, 18 },
	{ 21, 30 },
	{ 712, 728 },
	{ 858, 861 },
	{ 865, 871 },
	{ 873, 875 },
	{ 875, 877 }
};

static const int num_critical_sections = sizeof(critical_sections)
				       / sizeof(*critical_sections);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #ifndef __LINUX_HUB_H
#define __LINUX_HUB_H

/*
 * Hub protocol and driver data structures.
 *
 * Some of these are known to the "virtual root hub" code
 * in host controller drivers.
 */

#include <linux/list.h>
#include <linux/workqueue.h>
#include <linux/compiler.h>	/* likely()/unlikely() */

/*
 * Hub request types
 */

#define USB_RT_HUB	(USB_TYPE_CLASS | USB_RECIP_DEVICE)
#define USB_RT_PORT	(USB_TYPE_CLASS | USB_RECIP_OTHER)

/*
 * Hub class requests
 * See USB 2.0 spec Table 11-16
 */
#define HUB_CLEAR_TT_BUFFER	8
#define HUB_RESET_TT		9
#define HUB_GET_TT_STATE	10
#define HUB_STOP_TT		11

/*
 * Hub Class feature numbers
 * See USB 2.0 spec Table 11-17
 */
#define C_HUB_LOCAL_POWER	0
#define C_HUB_OVER_CURRENT	1

/*
 * Port feature numbers
 * See USB 2.0 spec Table 11-17
 */
#define USB_PORT_FEAT_CONNECTION	0
#define USB_PORT_FEAT_ENABLE		1
#define USB_PORT_FEAT_SUSPEND		2	/* L2 suspend */
#define USB_PORT_FEAT_OVER_CURRENT	3
#define USB_PORT_FEAT_RESET		4
#define USB_PORT_FEAT_L1		5	/* L1 suspend */
#define USB_PORT_FEAT_POWER		8
#define USB_PORT_FEAT_LOWSPEED		9
/* This value was never in Table 11-17 */
#define USB_PORT_FEAT_HIGHSPEED		10
/* This value is also fake */
#define USB_PORT_FEAT_SUPERSPEED	11
#define USB_PORT_FEAT_C_CONNECTION	16
#define USB_PORT_FEAT_C_ENABLE		17
#define USB_PORT_FEAT_C_SUSPEND		18
#define USB_PORT_FEAT_C_OVER_CURRENT	19
#define USB_PORT_FEAT_C_RESET		20
#define USB_PORT_FEAT_TEST              21
#define USB_PORT_FEAT_INDICATOR         22
#define USB_PORT_FEAT_C_POR