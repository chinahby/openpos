 : params->frequency < 470000000 ? 0x84 : 0x81);

	if (fe->ops.i2c_gate_ctrl)
		fe->ops.i2c_gate_ctrl(fe, 1);
	if (i2c_transfer (&ttusb->i2c_adap, &msg, 1) != 1)
		return -EIO;

	return 0;
}


static struct ves1820_config alps_tdbe2_config = {
	.demod_address = 0x09,
	.xin = 57840000UL,
	.invert = 1,
	.selagc = VES1820_SELAGC_SIGNAMPERR,
};

static u8 read_pwm(struct ttusb* ttusb)
{
	u8 b = 0xff;
	u8 pwm;
	struct i2c_msg msg[] = { { .addr = 0x50,.flags = 0,.buf = &b,.len = 1 },
				{ .addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1} };

	if ((i2c_transfer(&ttusb->i2c_adap, msg, 2) != 2) || (pwm == 0xff))
		pwm = 0x48;

	return pwm;
}


static int dvbc_philips_tdm1316l_tuner_set_params(struct dvb_frontend *fe, struct dvb_frontend_parameters *params)
{
	struct ttusb *ttusb = (struct ttusb *) fe->dvb->priv;
	u8 tuner_buf[5];
	struct i2c_msg tuner_msg = {.addr = 0x60,
				    .flags = 0,
				    .buf = tuner_buf,
				    .len = sizeof(tuner_buf) };
	int tuner_frequency = 0;
	u8 band, cp, filter;

	// determine charge pump
	tuner_frequency = params->frequency;
	if      (tuner_frequency <  87000000) {return -EINVAL;}
	else if (tuner_frequency < 130000000) {cp = 3; band = 1;}
	else if (tuner_frequency < 160000000) {cp = 5; band = 1;}
	else if (tuner_frequency < 200000000) {cp = 6; band = 1;}
	else if (tuner_frequency < 290000000) {cp = 3; band = 2;}
	else if (tuner_frequency < 420000000) {cp = 5; band = 2;}
	else if (tuner_frequency < 480000000) {cp = 6; band = 2;}
	else if (tuner_frequency < 620000000) {cp = 3; band = 4;}
	else if (tuner_frequency < 830000000) {cp = 5; band = 4;}
	else if (tuner_frequency < 895000000) {cp = 7; band = 4;}
	else {return -EINVAL;}

	// assume PLL filter should always be 8MHz for the moment.
	filter = 1;

	// calculate divisor
	// (Finput + Fif)/Fref; Fif = 36125000 Hz, Fref = 62500 Hz
	tuner_frequency = ((params->frequency + 36125000) / 62500);

	// setup tuner buffer
	tuner_buf[0] = tuner_frequency >> 8;
	tuner_buf[1] = tuner_frequency & 0xff;
	tuner_buf[2] = 0xc8;
	tuner_buf[3] = (cp << 5) | (filter << 3) | band;
	tuner_buf[4] = 0x80;

	if (fe->ops.i2c_gate_ctrl)
		fe->ops.i2c_gate_ctrl(fe, 1);
	if (i2c_transfer(&ttusb->i2c_adap, &tuner_msg, 1) != 1) {
		printk("dvb-ttusb-budget: dvbc_philips_tdm1316l_pll_set Error 1\n");
		return -EIO;
	}

	msleep(50);

	if (fe->ops.i2c_gate_ctrl)
		fe->ops.i2c_gate_ctrl(fe, 1);
	if (i2c_transfer(&ttusb->i2c_adap, &tuner_msg, 1) != 1) {
		printk("dvb-ttusb-budget: dvbc_philips_tdm1316l_pll_set Error 2\n");
		return -EIO;
	}

	msleep(1);

	return 0;
}

static u8 dvbc_philips_tdm1316l_inittab[] = {
	0x80, 0x21,
	0x80, 0x20,
	0x81, 0x01,
	0x81, 0x00,
	0x00, 0x09,
	0x01, 0x69,
	0x03, 0x00,
	0x04, 0x00,
	0x07, 0x00,
	0x08, 0x00,
	0x20, 0x00,
	0x21, 0x40,
	0x22, 0x00,
	0x23, 0x00,
	0x24, 0x40,
	0x25, 0x88,
	0x30, 0xff,
	0x31, 0x00,
	0x32, 0xff,
	0x33, 0x00,
	0x34, 0x50,
	0x35, 0x7f,
	0x36, 0x00,
	0x37, 0x20,
	0x38, 0x00,
	0x40, 0x1c,
	0x41, 0xff,
	0x42, 0x29,
	0x43, 0x20,
	0x44, 0xff,
	0x45, 0x00,
	0x46, 0x00,
	0x49, 0x04,
	0x4a, 0xff,
	0x4b, 0x7f,
	0x52, 0x30,
	0x55, 0xae,
	0x56, 0x47,
	0x57, 0xe1,
	0x58, 0x3a,
	0x5a, 0x1e,
	0x5b, 0x34,
	0x60, 0x00,
	0x63, 0x00,
	0x64, 0x00,
	0x65, 0x00,
	0x66, 0x00,
	0x67, 0x00,
	0x68, 0x00,
	0x69, 0x00,
	0x6a, 0x02,
	0x6b, 0x00,
	0x70, 0xff,
	0x71, 0x00,
	0x72, 0x00,
	0x73, 0x00,
	0x74, 0x0c,
	0x80, 0x00,
	0x81, 0x00,
	0x82, 0x00,
	0x83, 0x00,
	0x84, 0x04,
	0x85, 0x80,
	0x86, 0x24,
	0x87, 0x78,
	0x88, 0x00,
	0x89, 0x00,
	0x90, 0x01,
	0x91, 0x01,
	0xa0, 0x00,
	0xa1, 0x00,
	0xa2, 0x00,
	0xb0, 0x91,
	0xb1, 0x0b,
	0xc0, 0x4b,
	0xc1, 0x00,
	0xc2, 0x00,
	0xd0, 0x00,
	0xd1, 0x00,
	0xd2, 0x00,
	0xd3, 0x00,
	0xd4, 0x00,
	0xd5, 0x00,
	0xde, 0x00,
	0xdf, 0x00,
	0x61, 0x38,
	0x62, 0x0a,
	0x53, 0x13,
	0x59, 0x08,
	0x55, 0x00,
	0x56, 0x40,
	0x57, 0x08,
	0x58, 0x3d,
	0x88, 0x10,
	0xa0, 0x00,
	0xa0, 0x00,
	0xa0, 0x00,
	0xa0, 0x04,
	0xff, 0xff,
};

static struct stv0297_config dvbc_philips_tdm1316l_config = {
	.demod_address = 0x1c,
	.inittab = dvbc_philips_tdm1316l_inittab,
	.invert = 0,
};

static void frontend_init(struct ttusb* ttusb)
{
	switch(le16_to_cpu(t