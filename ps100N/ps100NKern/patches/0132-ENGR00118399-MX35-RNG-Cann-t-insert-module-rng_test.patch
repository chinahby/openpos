ts));

	*cprev = cnow;

	return ret;
}

static int ntty_ioctl_tiocgicount(struct port *port, void __user *argp)
{
	const struct async_icount cnow = port->tty_icount;
	struct serial_icounter_struct icount;

	icount.cts = cnow.cts;
	icount.dsr = cnow.dsr;
	icount.rng = cnow.rng;
	icount.dcd = cnow.dcd;
	icount.rx = cnow.rx;
	icount.tx = cnow.tx;
	icount.frame = cnow.frame;
	icount.overrun = cnow.overrun;
	icount.parity = cnow.parity;
	icount.brk = cnow.brk;
	icount.buf_overrun = cnow.buf_overrun;

	return copy_to_user(argp, &icount, sizeof(icount)) ? -EFAULT : 0;
}

static int ntty_ioctl(struct tty_struct *tty, struct file *file,
		      unsigned int cmd, unsigned long arg)
{
	struct port *port = tty->driver_data;
	void __user *argp = (void __user *)arg;
	int rval = -ENOIOCTLCMD;

	DBG1("******** IOCTL, cmd: %d", cmd);

	switch (cmd) {
	case TIOCMIWAIT: {
		struct async_icount cprev = port->tty_icount;

		rval = wait_event_interruptible(port->tty_wait,
				ntty_cflags_changed(port, arg, &cprev));
		break;
	} case TIOCGICOUNT:
		rval = ntty_ioctl_tiocgicount(port, argp);
		break;
	default:
		DBG1("ERR: 0x%08X, %d", cmd, cmd);
		break;
	};

	return rval;
}

/*
 * Called by the upper tty layer when tty b