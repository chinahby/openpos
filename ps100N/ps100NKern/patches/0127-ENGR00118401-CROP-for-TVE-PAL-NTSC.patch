fies;

		spin_unlock_irqrestore(&card->card_lock, flags);

	} else {
		struct FIRM_ID __iomem *firm_id;
		struct ZFW_CTRL __iomem *zfw_ctrl;
		struct BOARD_CTRL __iomem *board_ctrl;
		struct CH_CTRL __iomem *ch_ctrl;

		base_addr = card->base_addr;

		firm_id = base_addr + ID_ADDRESS;
		if (!cyz_is_loaded(card))
			return -ENODEV;

		zfw_ctrl = card->base_addr +
				(readl(&firm_id->zfwctrl_addr) & 0xfffff);
		board_ctrl = &zfw_ctrl->board_ctrl;
		ch_ctrl = zfw_ctrl->ch_ctrl;

#ifdef CY_DEBUG_OPEN
		printk(KERN_DEBUG "cyc startup Z card %d, channel %d, "
			"base_addr %p\n", card, channel, base_addr);
#endif
		spin_lock_irqsave(&card->card_lock, flags);

		cy_writel(&ch_ctrl[channel].op_mode, C_CH_ENABLE);
#ifdef Z_WAKE
#ifdef CONFIG_CYZ_INTR
		cy_writel(&ch_ctrl[channel].intr_enable,
			  C_IN_TXBEMPTY | C_IN_TXLOWWM | C_IN_RXHIWM |
			  C_IN_RXNNDT | C_IN_IOCTLW | C_IN_MDCD);
#else
		cy_writel(&ch_ctrl[channel].intr_enable,
			  C_IN_IOCTLW | C_IN_MDCD);
#endif				/* CONFIG_CYZ_INTR */
#else
#ifdef CONFIG_CYZ_INTR
		cy_writel(&ch_ctrl[channel].intr_enable,
			  C_IN_TXBEMPTY | C_IN_TXLOWWM | C_IN_RXHIWM |
			  C_IN_RXNNDT | C_IN_MDCD);
#else
		cy_writel(&ch_ctrl[channel].intr_enable, C_IN_MDCD);
#endif				/* CONFIG_CYZ_INTR */
#endif				/* Z_WAKE */

		retval = cyz_issue_cmd(card, channel, C_CM_IOCTL, 0L);
		if (retval != 0) {
			printk(KERN_ERR "cyc:startup(1) retval on ttyC%d was "
				"%x\n", info->line, retval);
		}

		/* Flush RX buffers before raising DTR and RTS */
		retval = cyz_issue_cmd(card, channel, C_CM_FLUSH_RX, 0L);
		if (retval != 0) {
			printk(KERN_ERR "cyc:startup(2) retval on ttyC%d was "
				"%x\n", info->line, retval);
		}

		/* set timeout !!! */
		/* set RTS and DTR !!! */
		cy_writel(&ch_ctrl[channel].rs_control,
			readl(&ch_ctrl[channel].rs_control) | C_RS_RTS |
			C_RS_DTR);
		retval = cyz_issue_cmd(card, channel, C_CM_IOCTLM, 0L);
		if (retval != 0) {
			printk(KERN_ERR "cyc:startup(3) retval on ttyC%d was "
				"%x\n", info->line, retval);
		}
#ifdef CY_DEBUG_DTR
		printk(KERN_DEBUG "cyc:startup raising Z DTR\n");
#endif

		/* enable send, recv, modem !!! */

		info->port.flags |= ASYNC_INITIALIZED;
		if (info->port.tty)
			clear_bit(TTY_IO_ERROR, &info->port.tty->flags);
		info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
		info->breakon = info->breakoff = 0;
		memset((char *)&info->idle_stats, 0, sizeof(info->idle_stats));
		info->idle_stats.in_use =
		info->idle_stats.recv_idle =
		info->idle_stats.xmit_idle = jiffies;

		spin_unlock_irqrestore(&card->card_lock, flags);
	}

#ifdef CY_DEBUG_OPEN
	printk(KERN_DEBUG "cyc startup done\n");
#endif
	return 0;

errout:
	spin_unlock_irqrestore(&card->card_lock, flags);
	return retval;
}				/* startup */

static void start_xmit(struct cyclades_port *info)
{
	struct cyclades_card *card;
	unsigned long flags;
	void __iomem *base_addr;
	int chip, channel, index;

	card = info->card;
	channel = info->line - card->first_line;
	if (!cy_is_Z(card)) {
		chip = channel >> 2;
		channel &= 0x03;
		index = card->bus_index;
		base_addr = card->base_addr + (cy_chip_offset[chip] << index);

		spin_lock_irqsave(&card->card_lock, flags);
		cy_writeb(base_addr + (CyCAR << index), channel);
		cy_writeb(base_addr + (CySRER << index),
			readb(base_addr + (CySRER << index)) | CyTxRdy);
		spin_unlock_irqrestore(&card->card_lock, flags);
	} else {
#ifdef CONFIG_CYZ_INTR
		int retval;

		spin_lock_irqsave(&card->card_lock, flags);
		retval = cyz_issue_cmd(card, channel, C_CM_INTBACK, 0L);
		if (retval != 0) {
			printk(KERN_ERR "cyc:start_xmit retval on ttyC%d was "
				"%x\n", info->line, retval);
		}
		spin_unlock_irqrestore(&card->card_lock, flags);
#else				/* CONFIG_CYZ_INTR */
		/* Don't have to do anything at this time */
#endif				/* CONFIG_CYZ_INTR */
	}
}				/* start_xmit */

/*
 * This routine shuts down a serial port; interrupts are disabled,
 * and DTR is dropped if the hangup on close termio flag is on.
 */
static void shutdown(struct cyclades_port *info)
{
	struct cyclades_card *card;
	unsigned long flags;
	void __iomem *base_addr;
	int chip, chann				    vout->display_bufs[1], 0, 0) != 0) {
+					    vout->display_bufs[0] + eba_offset,
+					    vout->display_bufs[1] + eba_offset, 0, 0) != 0) {
 			dev_err(dev, "Error initializing PP output buffer\n");
 			return -EINVAL;
 		}
@@ -1006,8 +1028,8 @@ static int init_PP(ipu_channel_params_t *params, vout_data *vout,
 					    out_pixel_fmt, out_width,
 					    out_height, out_stride,
 					    vout->rotate,
-					    vout->display_bufs[0],
-					    vout->display_bufs[1], 0, 0) != 0) {
+					    vout->display_bufs[0] + eba_offset,
+					    vout->display_bufs[1] + eba_offset, 0, 0) != 0) {
 			dev_err(dev, "Error initializing PP output buffer\n");
 			return -EINVAL;
 		}
@@ -1025,12 +1047,12 @@ static int init_PP(ipu_channel_params_t *params, vout_data *vout,
 									vout->pp_right_stripe.input_column);
 		ipu_update_channel_buffer(vout->post_proc_ch, IPU_OUTPUT_BUFFER,
 									0,
-									vout->display_bufs[0] +
+									vout->display_bufs[0] + eba_offset +
 									vout->pp_left_stripe.output_column);
 
 		ipu_update_channel_buffer(vout->post_proc_ch, IPU_OUTPUT_BUFFER,
 									1,
-									vout->display_bufs[0] +
+									vout->display_bufs[0] + eba_offset +
 									vout->pp_right_stripe.output_column);
 	}
 
@@ -1059,6 +1081,7 @@ static int mxc_v4l2out_streamon(vout_data * vout)
 	bool use_direct_adc = false;
 	mm_segment_t old_fs;
 	int rc = 0;
+	volatile u32 *address;
 
 	dev_dbg(dev, "mxc_v4l2out_streamon: field format=%d\n",
 		vout->field_fmt);
@@ -1293,6 +1316,8 @@ static int mxc_v4l2out_streamon(vout_data * vout)
 		}
 
 		vout->display_ch = ipu_ch;
+		vout->xres = fbvar.xres;
+		vout->yres = fbvar.yres;
 
 		if (vout->cur_disp_output == 3 || vout->cur_disp_output == 5) {
 			fbvar.bits_per_pixel = 16;
@@ -1300,9 +1325,14 @@ static int mxc_v4l2out_streamon(vout_data * vout)
 				fbvar.nonstd = IPU_PIX_FMT_UYVY;
 			else
 				fbvar.nonstd = 0;
+			if (vout->cur_disp_output == 3) {
+				fbvar.xres = out_width;
+				fbvar.yres = out_height;
+				vout->xres = fbvar.xres;
+				vout->yres = fbvar.yres;
+			}
 
-			fbvar.xres = fbvar.xres_virtual = out_width;
-			fbvar.yres = out_height;
+			fbvar.xres_virtual = out_width;
 			fbvar.yres_virtual = out_height * 2;
 		}
 
@@ -1327,9 +1357,14 @@ static int mxc_v4l2out_streamon(vout_data * vout)
 
 		vout->display_bufs[1] = fbi->fix.smem_start;
 		vout->display_bufs[0] = fbi->fix.smem_start +
-		    (fbi->fix.line_length * fbi->var.yres);
-		vout->display_buf_size = vout->crop_current.width *
-		    vout->crop_current.height * fbi->var.bits_per_pixel / 8;
+			(fbi->fix.line_length * vout->yres);
+		vout->display_buf_size = vout->xres *
+			vout->yres * fbi->var.bits_per_pixel / 8;
+		/* green screen */
+		address = phys_to_virt(vout->display_bufs[0]);
+		memset(address, 0x10, vout->display_buf_size);
+		address = phys_to_virt(vout->display_bufs[1]);
+		memset(address, 0x10, vout->display_buf_size);
 		if (INTERLACED_CONTENT(vout))
 			vout->post_proc_ch = MEM_VDI_PRP_VF_MEM;
 		else
@@ -2196,8 +2231,7 @@ mxc_v4l2out_do_ioctl(struct file *file,
 			}
 
 			/* only full screen supported for SDC BG and SDC DC */
-			if (vout->cur_disp_output == 4 ||
-			    vout->cur_disp_output == 5) {
+			if (vout->cur_disp_output == 4) {
 				crop->c = vout->crop_current;
 				break;
 			}
diff --git a/drivers/media/video/mxc/output/mxc_v4l2_output.h b/drivers/media/video/mxc/output/mxc_v4l2_output.h
index 45d7132..315e0ba 100644
--- a/drivers/media/video/mxc/output/mxc_v4l2_output.h
+++ b/drivers/media/video/mxc/output/mxc_v4l2_output.h
@@ -139,6 +139,9 @@ typedef struct _vout_data {
 	struct stripe_param pp_right_stripe; /* struct for split parameters */
 	/* IC ouput buffer number. Counting from 0 to 3 */
 	int pp_split_buf_num; /*  0..3 */
+	u16 bpp ; /* bit per pixel */
+	u16 xres; /* width of physical frame (BGs) */
+	u16 yres; /* heigth of physical frame (BGs)*/
 
 } vout_data;
 
-- 
1.5.4.4

