*************
 * Video Decoding
 **********************************************************************/

/*******  routines from the pencam program; hey, they work!  ********/

/*
 * STV0680 Vision Camera Chipset Driver
 * Copyright (C) 2000 Adam Harrison <adam@antispin.org>
*/

#define RED 0
#define GREEN 1
#define BLUE 2
#define AD(x, y, w) (((y)*(w)+(x))*3)

static void bayer_unshuffle (struct usb_stv *stv680, struct stv680_scratch *buffer)
{
	int x, y, i;
	int w = stv680->cwidth;
	int vw = stv680->cwidth, vh = stv680->cheight;
	unsigned int p = 0;
	int colour = 0, bayer = 0;
	unsigned char *raw = buffer->data;
	struct stv680_frame *frame = &stv680->frame[stv680->curframe];
	unsigned char *output = frame->data;
	unsigned char *temp = frame->data;
	int offset = buffer->offset;

	if (frame->curpix == 0) {
		if (frame->grabstate == FRAME_READY) {
			frame->grabstate = FRAME_GRABBING;
		}
	}
	if (offset != frame->curpix) {	/* Regard frame as lost :( */
		frame->curpix = 0;
		stv680->error++;
		return;
	}

	if ((stv680->vwidth == 320) || (stv680->vwidth == 160)) {
		vw = 320;
		vh = 240;
	}
	if ((stv680->vwidth == 352) || (stv680->vwidth == 176)) {
		vw = 352;
		vh = 288;
	}

	memset (output, 0, 3 * vw * vh);	/* clear output matrix. */

	for (y = 0; y < vh; y++) {
		for (x = 0; x < vw; x++) {
			if (x & 1)
				p = *(raw + y * w + (x >> 1));
			else
				p = *(raw + y * w + (x >> 1) + (w >> 1));

			if (y & 1)
				bayer = 2;
			else
				bayer = 0;
			if (x & 1)
				bayer++;

			switch (bayer) {
			case 0:
			case 3:
				colour = 1;
				break;
			case 1:
				colour = 0;
				break;
			case 2:
				colour = 2;
				break;
			}
			i = (y * vw + x) * 3;
			*(output + i + colour) = (unsigned char) p;
		}		/* for x */

	}			/* for y */

	/****** gamma correction plus hardcoded white balance */
	/* Thanks to Alexander Schwartx <alexander.schwartx@gmx.net> for this code.
	   Correction values red[], green[], blue[], are generated by
	   (pow(i/256.0, GAMMA)*255.0)*white balanceRGB where GAMMA=0.55, 1<i<255.
	   White balance (RGB)= 1.0, 1.17, 1.48. Values are calculated as double float and
	   converted to unsigned char. Values are in stv680.h  */

	for (y = 0; y < vh; y++) {
		for (x = 0; x < vw; x++) {
			i = (y * vw + x) * 3;
			*(output + i) = red[*(output + i)];
			*(output + i + 1) = green[*(output + i + 1)];
			*(output + i + 2) = blue[*(output + i + 2)];
		}
	}

	/******  bayer demosaic  ******/
	for (y = 1; y < (vh - 1); y++) {
		for (x = 1; x < (vw - 1); x++) {	/* work out pixel type */
			if (y & 1)
				bayer = 0;
			else
				bayer = 2;
			if (!(x & 1))
				bayer++;

			switch (bayer) {
			case 0:	/* green. blue lr, red tb */
				*(output + AD (x, y, vw) + BLUE) = ((int) *(output + AD (x - 1, y, vw) + BLUE) + (int) *(output + AD (x + 1, y, vw) + BLUE)) >> 1;
				*(output + AD (x, y, vw) + RED) = ((int) *(output + AD (x, y - 1, vw) + RED) + (int) *(output + AD (x, y + 1, vw) + RED)) >> 1;
				break;

			case 1:	/* blue. green lrtb, red diagonals */
				*(output + AD (x, y, vw) + GREEN) = ((int) *(output + AD (x - 1, y, vw) + GREEN) + (int) *(output + AD (x + 1, y, vw) + GREEN) + (int) *(output + AD (x, y - 1, vw) + GREEN) + (int) *(output + AD (x, y + 1, vw) + GREEN)) >> 2;
				*(output + AD (x, y, vw) + RED) = ((int) *(output + AD (x - 1, y - 1, vw) + RED) + (int) *(output + AD (x - 1, y + 1, vw) + RED) + (int) *(output + AD (x + 1, y - 1, vw) + RED) + (int) *(output + AD (x + 1, y + 1, vw) + RED)) >> 2;
				break;

			case 2:	/* red. green lrtb, blue diagonals */
				*(output + AD (x, y, vw) + GREEN) = ((int) *(output + AD (x - 1, y, vw) + GREEN) + (int) *(output + AD (x + 1, y, vw) + GREEN) + (int) *(output + AD (x, y - 1, vw) + GREEN) + (int) *(output + AD (x, y + 1, vw) + GREEN)) >> 2;
				*(output + AD (x, y, vw) + BLUE) = ((int) *(output + AD (x - 1, y - 1, vw) + BLUE) + (int) *(output + AD (x + 1, y - 1, vw) + BLUE) + (int) *(output + AD (x - 1, y + 1, vw) + BLUE) + (int) *(output + AD (x + 1, y + 1, vw) + BLUE)) >> 2;
				break;

			case 3:	/* green. red lr, blue tb */
				*(output + AD (x, y, vw) + RED) = ((int) *(output + AD (x - 1, y, vw) + RED) + (int) *(output + AD (x + 1, y, vw) + RED)) >> 1;
				*(output + AD (x, y, vw) + BLUE) = ((int) *(output + AD (x, y - 1, vw) + BLUE) + (int) *(output + AD (x, y + 1, vw) + BLUE)) >> 1;
				break;
			}	/* switch */
		}		/* for x */
	}			/* for y  - end demosaic  */

	/* fix top and bottom row, left and right side */
	i = vw * 3;
	memcpy (output, (output + i), i);
	memcpy ((output + (vh * i)), (output + ((vh - 1) * i)), i);
	for (y = 0; y < vh; y++) {
		i = y * vw * 3;
		memcpy ((output + i), (output + i + 3), 3);
		memcpy ((output + i + (vw * 3)), (output + i + (vw - 1) * 3), 3);
	}

	/*  process all raw data, then trim to size if necessary */
	if ((stv680->vwidth == 160) || (stv680->vwidth == 176))  {
		i = 0;
		for (y = 0; y < vh; y++) {
			if (!(y & 1)) {
				for (x = 0; x < vw; x++) {
					p = (y * vw + x) * 3;
					if (!(x & 1)) {
						*(output + i) = *(output + p);
						*(output + i + 1) = *(output + p + 1);
						*(output + i + 2) = *(output + p + 2);
						i += 3;
					}
				}  /* for x */
			}
		}  /* for y */
	}
	/* reset to proper width */
	if ((stv680->vwidth == 160)) {
		vw = 160;
		vh = 120;
	}
	if ((stv680->vwidth == 176)) {
		vw = 176;
		vh = 144;
	}

	/* output is RGB; some programs want BGR  */
	/* swapRGB_on=0 -> program decides;  swapRGB_on=1, always swap */
	/* swapRGB_on=-1, never swap */
	if (((swapRGB == 1) && (swapRGB_on != -1)) || (swapRGB_on == 1)) {
		for (y = 0; y < vh; y++) {
			for (x = 0; x < vw; x++) {
				i = (y * vw + x) * 3;
				*(temp) = *(output + i);
				*(output + i) = *(output + i + 2);
				*(output + i + 2) = *(temp);
			}
		}
	}
	/* brightness */
	if (stv680->chgbright == 1) {
		if (stv680->brightness >= 32767) {
			p = (stv680->brightness - 32767) / 256;
			for (x = 0; x < (vw * vh * 3); x++) {
				if ((*(output + x) + (unsigned char) p) > 255)
					*(output + x) = 255;
				else
					*(output + x) += (unsigned char) p;
			}	/* for */
		} else {
			p = (32767 - stv680->brightness) / 256;
			for (x = 0; x < (vw * vh * 3); x++) {
				if ((unsigned char) p > *(output + x))
					*(output + x) = 0;
				else
					*(output + x) -= (unsigned char) p;
			}	/* for */
		}		/* else */
	}
	/* if */
	frame->curpix = 0;
	frame->curlinepix = 0;
	frame->grabstate = FRAME_DONE;
	stv680->framecount++;
	stv680->readcount++;
	if (stv680->frame[(stv680->curframe + 1) & (STV680_NUMFRAMES - 1)].grabstate == FRAME_READY) {
		stv680->curframe = (stv680->curframe + 1) & (STV680_NUMFRAMES - 1);
	}

}				/* bayer_unshuffle */

/*******  end routines from the pencam program  *********/

static int stv680_newframe (struct usb_stv *stv680, int framenr)
{
	int errors = 0;

	while (stv680->streaming && (stv680->frame[framenr].grabstate == FRAME_READY || stv680->frame[framenr].grabstate == FRAME_GRABBING)) {
		if (!stv680->frame[framenr].curpix) {
			errors++;
		}
		wait_event_interruptible (stv680->wq, (stv680->scratch[stv680->scratch_use].state == BUFFER_READY));

		if (stv680->nullpackets > STV680_MAX_NULLPACKETS) {
			stv680->nullpackets = 0;
			PDEBUG (2, "STV(i): too many null length packets, restarting capture");
			stv680_stop_stream (stv680);
			stv680_start_stream (stv680);
		} else {
			if (stv680->scratch[stv680->scratch_use].state != BUFFER_READY) {
				stv680->frame[framenr].grabstate = FRAME_ERROR;
				PDEBUG (2, "STV(e): FRAME_ERROR in _newframe");
				return -EIO;
			}
			stv680->scratch[stv680->scratch_use].state = BUFFER_BUSY;

			bayer_unshuffle (stv680, &stv680->scratch[stv680->scratch_use]);

			stv680->scratch[stv680->scratch_use].state = BUFFER_UNUSED;
			stv680->scratch_use++;
			if (stv680->scratch_use >= STV680_NUMSCRATCH)
				stv680->scratch_use = 0;
			if (errors > STV680_MAX_ERRORS) {
				errors = 0;
				PDEBUG (2, "STV(i): too many errors, restarting capture");
				stv680_stop_stream (stv680);
				stv680_start_stream (stv680);
			}
		}		/* else */
	}			/* while */
	return 0;
}

/*********************************************************************
 * Video4Linux
 *********************************************************************/

static int stv_open(struct file *file)
{
	struct video_device *dev = video_devdata(file);
	struct usb_stv *stv680 = video_get_drvdata(dev);
	int err = 0;

	/* we are called with the BKL held */
	lock_kernel();
	stv680->user = 1;
	err = stv_init (stv680);	/* main initialization routine for camera */

	if (err >= 0) {
		stv680->fbuf = rvmalloc (stv680->maxframesize * STV680_NUMFRAMES);
		if (!stv680->fbuf) {
			PDEBUG (0, "STV(e): Could not rvmalloc frame bufer");
			err = -ENOMEM;
		}
		file->private_data = dev;
	}
	if (err)
		stv680->user = 0;
	unlock_kernel();

	return err;
}

static int stv_close(struct file *file)
{
	struct video_device *dev = file->private_data;
	struct usb_stv *stv680 = video_get_drvdata(dev);
	int i;

	for (i = 0; i < STV680_NUMFRAMES; i++)
		stv680->frame[i].grabstate = FRAME_UNUSED;
	if (stv680->streaming)
		stv680_stop_stream (stv680);

	if ((i = stv_stop_video (stv680)) < 0)
		PDEBUG (1, "STV(e): stop_video failed in stv_close");

	rvfree (stv680->fbuf, stv680->maxframesize * STV680_NUMFRAMES);
	stv680->user = 0;

	if (stv680->removed) {
		kfree(stv680);
		stv680 = NULL;
		PDEBUG (0, "STV(i): device unregistered");
	}
	file->private_data = NULL;
	return 0;
}

static long stv680_do_ioctl(struct file *file, unsigned int cmd, void *arg)
{
	struct video_device *vdev = file->private_data;
	struct usb_stv *stv680 = video_get_drvdata(vdev);

	if (!stv680->udev)
		return -EIO;

	switch (cmd) {
	case VIDIOCGCAP:{
			struct video_capability *b = arg;

			strcpy (b->name, stv680->camera_name);
			b->type = VID_TYPE_CAPTURE;
			b->channels = 1;
			b->audios = 0;
			b->maxwidth = stv680->maxwidth;
			b->maxheight = stv680->maxheight;
			b->minwidth = stv680->maxwidth / 2;
			b->minheight = stv680->maxheight / 2;
			return 0;
		}
	case VIDIOCGCHAN:{
			struct video_channel *v = arg;

			if (v->channel != 0)
				return -EINVAL;
			v->flags = 0;
			v->tuners = 0;
			v->type = VIDEO_TYPE_CAMERA;
			strcpy (v->name, "STV Camera");
			return 0;
		}
	case VIDIOCSCHAN:{
			struct video_channel *v = arg;
			if (v->channel != 0)
				return -EINVAL;
			return 0;
		}
	case VIDIOCGPICT:{
			struct video_picture *p = arg;

			stv680_get_pict (stv680, p);
			return 0;
		}
	case VIDIOCSPICT:{
			struct video_picture *p = arg;

			if (stv680_set_pict (stv680, p))
				return -EINVAL;
			return 0;
		}
	case VIDIOCSWIN:{
			struct video_window *vw = arg;

			if (vw->flags)
				return -EINVAL;
			if (vw->clipcount)
				return -EINVAL;
			if (vw->width != stv680->vwidth) {
				if (stv680_set_size (stv680, vw->width, vw->height)) {
					PDEBUG (2, "STV(e): failed (from user) set size in VIDIOCSWIN");
					return -EINVAL;
				}
			}
			return 0;
		}
	case VIDIOCGWIN:{
			struct video_window *vw = arg;

			vw->x = 0;	/* FIXME */
			vw->y = 0;
			vw->chromakey = 0;
			vw->flags = 0;
			vw->clipcount = 0;
			vw->width = stv680->vwidth;
			vw->height = stv680->vheight;
			return 0;
		}
	case VIDIOCGMBUF:{
			struct video_mbuf *vm = arg;
			int i;

			memset (vm, 0, sizeof (*vm));
			vm->size = STV680_NUMFRAMES * stv680->maxframesize;
			vm->frames = STV680_NUMFRAMES;
			for (i = 0; i < STV680_NUMFRAMES; i++)
				vm->offsets[i] = stv680->maxframesize * i;
			return 0;
		}
	case VIDIOCMCAPTURE:{
			struct video_mmap *vm = arg;

			if (vm->format != STV_VIDEO_PALETTE) {
				PDEBUG (2, "STV(i): VIDIOCMCAPTURE vm.format (%i) != VIDEO_PALETTE (%i)",
					vm->format, STV_VIDEO_PALETTE);
				if ((vm->format == 3) && (swapRGB_on == 0))  {
					PDEBUG (2, "STV(i): VIDIOCMCAPTURE swapRGB is (auto) ON");
					/* this may fix those apps (e.g., xawtv) that want BGR */
					swapRGB = 1;
				}
				return -EINVAL;
			}
			if (vm->frame >= STV680_NUMFRAMES) {
				PDEBUG (2, "STV(e): VIDIOCMCAPTURE vm.frame > NUMFRAMES");
				return -EINVAL;
			}
			if ((stv680->frame[vm->frame].grabstate == FRAME_ERROR)
			    || (stv680->frame[vm->frame].grabstate == FRAME_GRABBING)) {
				PDEBUG (2, "STV(e): VIDIOCMCAPTURE grabstate (%i) error",
					stv680->frame[vm->frame].grabstate);
				return -EBUSY;
			}
			/* Is this according to the v4l spec??? */
			if (stv680->vwidth != vm->width) {
				if (stv680_set_size (stv680, vm->width, vm->height)) {
					PDEBUG (2, "STV(e): VIDIOCMCAPTURE set_size failed");
					return -EINVAL;
				}
			}
			stv680->frame[vm->frame].grabstate = FRAME_READY;

			if (!stv680->streaming)
				stv680_start_stream (stv680);

			return 0;
		}
	case VIDIOCSYNC:{
			int *frame = arg;
			int ret = 0;

			if (*frame < 0 || *frame >= STV680_NUMFRAMES) {
				PDEBUG (2, "STV(e): Bad frame # in VIDIOCSYNC");
				return -EINVAL;
			}
			ret = stv680_newframe (stv680, *frame);
			stv680->frame[*frame].grabstate = FRAME_UNUSED;
			return ret;
		}
	case VIDIOCGFBUF:{
			struct video_buffer *vb = arg;

			memset (vb, 0, sizeof (*vb));
			return 0;
		}
	case VIDIOCKEY:
		return 0;
	case VIDIOCCAPTURE:
		{
			PDEBUG (2, "STV(e): VIDIOCCAPTURE failed");
			return -EINVAL;
		}
	case VIDIOCSFBUF:
	case VIDIOCGTUNER:
	case VIDIOCSTUNER:
	case VIDIOCGFREQ:
	case VIDIOCSFREQ:
	case VIDIOCGAUDIO:
	case VIDIOCSAUDIO:
		return -EINVAL;
	default:
		return -ENOIOCTLCMD;
	}			/* end switch */

	return 0;
}

static long stv680_ioctl(struct file *file,
			unsigned int cmd, unsigned long arg)
{
	return video_usercopy(file, cmd, arg, stv680_do_ioctl);
}

static int stv680_mmap (struct file *file, struct vm_area_struct *vma)
{
	struct video_device *dev = file->private_data;
	struct usb_stv *stv680 = video_get_drvdata(dev);
	unsigned long start = vma->vm_start;
	unsigned long size  = vma->vm_end-vma->vm_start;
	unsigned long page, pos;

	mutex_lock(&stv680->lock);

	if (stv680->udev == NULL) {
		mutex_unlock(&stv680->lock);
		return -EIO;
	}
	if (size > (((STV680_NUMFRAMES * stv680->maxframesize) + PAGE_SIZE - 1)
		    & ~(PAGE_SIZE - 1))) {
		mutex_unlock(&stv680->lock);
		return -EINVAL;
	}
	pos = (unsigned long) stv680->fbuf;
	while (size > 0) {
		page = vmalloc_to_pfn((void *)pos);
		if (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED)) {
			mutex_unlock(&stv680->lock);
			return -EAGAIN;
		}
		start += PAGE_SIZE;
		pos += PAGE_SIZE;
		if (size > PAGE_SIZE)
			size -= PAGE_SIZE;
		else
			size = 0;
	}
	mutex_unlock(&stv680->lock);

	return 0;
}

static ssize_t stv680_read (struct file *file, char __user *buf,
			size_t count, loff_t *ppos)
{
	struct video_device *dev = file->private_data;
	unsigned long int realcount = count;
	int ret = 0;
	struct usb_stv *stv680 = video_get_drvdata(dev);
	unsigned long int i;

	if (STV680_NUMFRAMES != 2) {
		PDEBUG (0, "STV(e): STV680_NUMFRAMES needs to be 2!");
		return -1;
	}
	if (stv680->udev == NULL)
		return -EIO;
	if (realcount > (stv680->vwidth * stv680->vheight * 3))
		realcount = stv680->vwidth * stv680->vheight * 3;

	/* Shouldn't happen: */
	if (stv680->frame[0].grabstate == FRAME_GRABBING) {
		PDEBUG (2, "STV(e): FRAME_GRABBING in stv680_read");
		return -EBUSY;
	}
	stv680->frame[0].grabstate = FRAME_READY;
	stv680->frame[1].grabstate = FRAME_UNUSED;
	stv680->curframe = 0;

	if (!stv680->streaming)
		stv680_start_stream (stv680);

	if (!stv680->streaming) {
		ret = stv680_newframe (stv680, 0);	/* ret should = 0 */
	}

	ret = stv680_newframe (stv680, 0);

	if (!ret) {
		if ((i = copy_to_user (buf, stv680->frame[0].data, realcount)) != 0) {
			PDEBUG (2, "STV(e): copy_to_user frame 0 failed, ret count = %li", i);
			return -EFAULT;
		}
	} else {
		realcount = ret;
	}
	stv680->frame[0].grabstate = FRAME_UNUSED;
	return realcount;
}				/* stv680_read */

static const struct v4l2_file_operations stv680_fops = {
	.owner =	THIS_MODULE,
	.open =		stv_open,
	.release =     	stv_close,
	.read =		stv680_read,
	.mmap =		stv680_mmap,
	.ioctl =        stv680_ioctl,
};
static struct video_device stv680_template = {
	.name =		"STV0680 USB camera",
	.fops =         &stv680_fops,
	.release =	video_device_release,
	.minor = 	-1,
};

static int stv680_probe (struct usb_interface *intf, const struct usb_device_id *id)
{
	struct usb_device *dev = interface_to_usbdev(intf);
	struct usb_host_interface *interface;
	struct usb_stv *stv680 = NULL;
	char *camera_name = NULL;
	int retval = 0;

	/* We don't handle multi-config cameras */
	if (dev->descriptor.bNumConfigurations != 1) {
		PDEBUG (0, "STV(e): Number of Configurations != 1");
		return -ENODEV;
	}

	interface = &intf->altsetting[0];
	/* Is it a STV680? */
	if ((le16_to_cpu(dev->descriptor.idVendor) == USB_PENCAM_VENDOR_ID) &&
	    (le16_to_cpu(dev->descriptor.idProduct) == USB_PENCAM_PRODUCT_ID)) {
		camera_name = "STV0680";
		PDEBUG (0, "STV(i): STV0680 camera found.");
	} else if ((le16_to_cpu(dev->descriptor.idVendor) == USB_CREATIVEGOMINI_VENDOR_ID) &&
		   (le16_to_cpu(dev->descriptor.idProduct) == USB_CREATIVEGOMINI_PRODUCT_ID)) {
		camera_name = "Creative WebCam Go Mini";
		PDEBUG (0, "STV(i): Creative WebCam Go Mini found.");
	} else {
		PDEBUG (0, "STV(e): Vendor/Product ID do not match STV0680 or Creative WebCam Go Mini values.");
		PDEBUG (0, "STV(e): Check that the STV0680 or Creative WebCam Go Mini camera is connected to the computer.");
		retval = -ENODEV;
		goto error;
	}
	/* We found one */
	if ((stv680 = kzalloc (sizeof (*stv680), GFP_KERNEL)) == NULL) {
		PDEBUG (0, "STV(e): couldn't kmalloc stv680 struct.");
		retval = -ENOMEM;
		goto error;
	}

	stv680->udev = dev;
	stv680->camera_name = camera_name;

	stv680->vdev = video_device_alloc();
	if (!stv680->vdev) {
		retval = -ENOMEM;
		goto error;
	}
	memcpy(stv680->vdev, &stv680_template, sizeof(stv680_template));
	stv680->vdev->parent = &intf->dev;
	video_set_drvdata(stv680->vdev, stv680);

	memcpy (stv680->vdev->name, stv680->camera_name, strlen (stv680->camera_name));
	init_waitqueue_head (&stv680->wq);
	mutex_init (&stv680->lock);
	wmb ();

	if (video_register_device(stv680->vdev, VFL_TYPE_GRABBER, video_nr) < 0) {
		PDEBUG (0, "STV(e): video_register_device failed");
		retval = -EIO;
		goto error_vdev;
	}
	PDEBUG(0, "STV(i): registered new video device: video%d",
		stv680->vdev->num);

	usb_set_intfdata (intf, stv680);
	retval = stv680_create_sysfs_files(stv680->vdev);
	if (retval)
		goto error_unreg;
	return 0;

error_unreg:
	video_unregister_device(stv680->vdev);
error_vdev:
	video_device_release(stv680->vdev);
error:
	kfree(stv680);
	return retval;
}

static inline void usb_stv680_remove_disconnected (struct usb_stv *stv680)
{
	int i;

	stv680->udev = NULL;
	stv680->frame[0].grabstate = FRAME_ERROR;
	stv680->frame[1].grabstate = FRAME_ERROR;
	stv680->streaming = 0;

	wake_up_interruptible (&stv680->wq);

	for (i = 0; i < STV680_NUMSBUF; i++)
		if (stv680->urb[i]) {
			usb_kill_urb (stv680->urb[i]);
			usb_free_urb (stv680->urb[i]);
			stv680->urb[i] = NULL;
			kfree(stv680->sbuf[i].data);
		}
	for (i = 0; i < STV680_NUMSCRATCH; i++)
		kfree(stv680->scratch[i].data);
	PDEBUG (0, "STV(i): %s disconnected", stv680->camera_name);

	/* Free the memory */
	kfree(stv680);
}

static void stv680_disconnect (struct usb_interface *intf)
{
	struct usb_stv *stv680 = usb_get_intfdata (intf);

	usb_set_intfdata (intf, NULL);

	if (stv680) {
		/* We don't want people trying to open up the device */
		if (stv680->vdev) {
			stv680_remove_sysfs_files(stv680->vdev);
			video_unregister_device(stv680->vdev);
			stv680->vdev = NULL;
		}
		if (!stv680->user) {
			usb_stv680_remove_disconnected (stv680);
		} else {
			stv680->removed = 1;
		}
	}
}

static struct usb_driver stv680_driver = {
	.name =		"stv680",
	.probe =	stv680_probe,
	.disconnect =	stv680_disconnect,
	.id_table =	device_table
};

/********************************************************************
 *  Module routines
 ********************************************************************/

static int __init usb_stv680_init (void)
{
	if (usb_register (&stv680_driver) < 0) {
		PDEBUG (0, "STV(e): Could not setup STV0680 driver");
		return -1;
	}
	PDEBUG (0, "STV(i): usb camera driver version %s registering", DRIVER_VERSION);

	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
	       DRIVER_DESC "\n");
	return 0;
}

static void __exit usb_stv680_exit (void)
{
	usb_deregister (&stv680_driver);
	PDEBUG (0, "STV(i): driver deregistered");
}

module_init (usb_stv680_init);
module_exit (usb_stv680_exit);
                                                                                                         /* mac_esp.c: ESP front-end for Macintosh Quadra systems.
 *
 * Adapted from jazz_esp.c and the old mac_esp.c.
 *
 * The pseudo DMA algorithm is based on the one used in NetBSD.
 * See sys/arch/mac68k/obio/esp.c for some background information.
 *
 * Copyright (C) 2007-2008 Finn Thain
 */

#include <linux/kernel.h>
#include <linux/types.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/platform_device.h>
#include <linux/dma-mapping.h>
#include <linux/scatterlist.h>
#include <linux/delay.h>
#include <linux/io.h>
#include <linux/nubus.h>

#include <asm/irq.h>
#include <asm/dma.h>

#include <asm/macints.h>
#include <asm/macintosh.h>

#include <scsi/scsi_host.h>

#include "esp_scsi.h"

#define DRV_MODULE_NAME     "mac_esp"
#define PFX                 DRV_MODULE_NAME ": "
#define DRV_VERSION         "1.000"
#define DRV_MODULE_RELDATE  "Sept 15, 2007"

#define MAC_ESP_IO_BASE          0x50F00000
#define MAC_ESP_REGS_QUADRA      (MAC_ESP_IO_BASE + 0x10000)
#define MAC_ESP_REGS_QUADRA2     (MAC_ESP_IO_BASE + 0xF000)
#define MAC_ESP_REGS_QUADRA3     (MAC_ESP_IO_BASE + 0x18000)
#define MAC_ESP_REGS_SPACING     0x402
#define MAC_ESP_PDMA_REG         0xF9800024
#define MAC_ESP_PDMA_REG_SPACING 0x4
#define MAC_ESP_PDMA_IO_OFFSET   0x100

#define esp_read8(REG)		mac_esp_read8(esp, REG)
#define esp_write8(VAL, REG)	mac_esp_write8(esp, VAL, REG)

struct mac_esp_priv {
	struct esp *esp;
	void __iomem *pdma_regs;
	void __iomem *pdma_io;
	int error;
};
static struct platform_device *internal_pdev, *external_pdev;
static struct esp *esp_chips[2];

#define MAC_ESP_GET_PRIV(esp) ((struct mac_esp_priv *) \
			       platform_get_drvdata((struct platform_device *) \
						    (esp->dev)))

static inline void mac_esp_write8(struct esp *esp, u8 val, unsigned long reg)
{
	nubus_writeb(val, esp->regs + reg * 16);
}

static inline u8 mac_esp_read8(struct esp *esp, unsigned long reg)
{
	return nubus_readb(esp->regs + reg * 16);
}

/* For pseudo DMA and PIO we need the virtual address
 * so this address mapping is the identity mapping.
 */

static dma_addr_t mac_esp_map_single(struct esp *esp, void *buf,
				     size_t sz, int dir)
{
	return (dma_addr_t)buf;
}