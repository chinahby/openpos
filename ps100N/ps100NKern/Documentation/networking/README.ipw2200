re
 */
int prp_vf_select(void *private)
{
	int ret = 0;
	cam_data *cam = (cam_data *) private;

	if (cam) {
		cam->vf_start_sdc = prp_vf_start;
		cam->vf_stop_sdc = prp_vf_stop;
		cam->overlay_active = false;
	} else
		ret = -EIO;

	return ret;
}

/*!
 * @brief Uninstall overlay functions.
 * @param private	Pointer to cam_data structure
 * @return		Zero on success, others on failure
 */
int prp_vf_deselect(void *private)
{
	int ret = 0;
	cam_data *cam = (cam_data *) private;

	ret = prp_vf_stop(private);

	if (cam) {
		cam->vf_start_sdc = NULL;
		cam->vf_stop_sdc = NULL;
	}

	return ret;
}

/*!
 * @brief Start still picture capture.
 * @param private	Pointer to cam_data structure
 * @return		Zero on success, others on failure
 */
static int prp_still_start(void *private)
{
	cam_data *cam = (cam_data *) private;

	g_still_on = 1;
	g_prp_cfg.ch2_ptr = (unsigned int)cam->still_buf;
	g_prp_cfg.ch2_ptr2 = 0;

	if (prp_v4l2_cfg(&g_prp_cfg, cam))
		return -1;

	csi_enable_mclk(CSI_MCLK_RAW, true, true);
	prphw_reset();

	if (prphw_cfg(&g_prp_cfg)) {
		g_still_on = 0;
		return -1;
	}

	prphw_enable(cam->overlay_on ? (PRP_CHANNEL_1 | PRP_CHANNEL_2)
		     : PRP_CHANNEL_2);

	return 0;
}

/*!
 * @brief Stop still picture capture.
 * @param private	Pointer to cam_data structure
 * @return		Zero on success, others on failure
 */
static int prp_still_stop(void *private)
{
	prphw_disable(PRP_CHANNEL_2);

	csi_enable_mclk(CSI_MCLK_RAW, false, false);

	g_still_on = 0;

	return 0;
}

/*!
 * @brief Setup functions for still picture capture.
 * @param private	Pointer to cam_data structure
 * @return		Zero on success, others on failure
 */
int prp_still_select(void *private)
{
	cam_data *cam = (cam_data *) private;

	if (cam) {
		cam->csi_start = prp_still_start;
		cam->csi_stop = prp_still_stop;
	}

	return 0;
}

/*!
 * @brief Uninstall functions for still picture capture.
 * @param private	Pointer to cam_data structure
 * @return		Zero on success, others on failure
 */
int prp_still_deselect(void *private)
{
	cam_data *cam = (cam_data *) private;
	int err = 0;

	err = prp_still_stop(cam);

	if (cam) {
		cam->csi_start = NULL;
		cam->csi_stop = NULL;
	}

	return err;
}

/*!
 * @brief Perform software rotation or mirroring
 * @param private	Argument passed to the tasklet
 */
static void rotation(unsigned long private)
{
	char *src, *dst;
	int width, height, s_stride, d_stride;
	int size;
	cam_data *cam = (cam_data *) private;

	src = g_vaddr_rotbuf[g_rotbuf];
	size = cam->rot_vf_buf_size[g_rotbuf];

	if ((cam->rotation == V4L2_MXC_ROTATE_90_RIGHT)
	    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_VFLIP)
	    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_HFLIP)
	    || (cam->rotation == V4L2_MXC_ROTATE_90_LEFT)) {
		width = cam->win.w.height;
		height = cam->win.w.width;
		s_stride = cam->win.w.height << 1;
	} else {
		width = cam->win.w.width;
		height = cam->win.w.height;
		s_stride = cam->win.w.width << 1;
	}

	if (cam->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
		dst = g_vaddr_vfbuf[g_vfbuf];
		d_stride = cam->win.w.width << 1;
	} else {		/* The destination is the framebuffer */
		struct fb_info *fb = cam->overlay_fb;
		if (!fb)
			return;
		dst = g_vaddr_fb;
		dst += cam->win.w.top * fb->var.xres_virtual
		    * (fb->var.bits_per_pixel >> 3)
		    + cam->win.w.left * (fb->var.bits_per_pixel >> 3);
		d_stride = fb->var.xres_virtual << 1;
	}

	/*
	 * Invalidate the data in cache before performing the SW rotaion
	 * or mirroring in case the image size is less than QVGA. For image
	 * larger than QVGA it is not invalidated becase the invalidation
	 * will consume much time while we don't see any artifacts on the
	 * output if we don't perform invalidation for them.
	 * Similarly we don't flush the data after SW rotation/mirroring.
	 */
	if (size < 320 * 240 * 2)
		dmac_inv_range(src, src + size);
	switch (cam->rotation) {
	case V4L2_MXC_ROTATE_VERT_FLIP:
		opl_vmirror_u16(src, s_stride, width, height, dst, d_stride);
		break;
	case V4L2_MXC_ROTATE_HORIZ_FLIP:
		opl_hmirror_u16(src, s_stride, width, height, dst, d_stride);
		break;
	case V4L2_MXC_ROTATE_180:
		opl_rotate180_u16(src, s_stride, width, height, dst, d_stride);
		break;
	case V4L2_MXC_ROTATE_90_RIGHT:
		opl_rotate90_u16(src, s_stride, width, height, dst, d_stride);
		break;
	case V4L2_MXC_ROTATE_90_RIGHT_VFLIP:
		opl_rotate90_vmirror_u16(src, s_stride, width, height, dst,
					 d_stride);
		break;
	case V4L2_MXC_ROTATE_90_RIGHT_HFLIP:
		/* ROTATE_90_RIGHT_HFLIP = ROTATE_270_RIGHT_VFLIP */
		opl_rotate270_vmirror_u16(src, s_stride, width, height, dst,
					  d_stride);
		break;
	case V4L2_MXC_ROTATE_90_LEFT:
		opl_rotate270_u16(src, s_stride, width, height, dst, d_stride);
		break;
	default:
		return;
	}

	/* Config and display the graphic window */
	if (cam->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
		struct fb_gwinfo gwinfo;

		gwinfo.enabled = 1;
		gwinfo.alpha_value = 255;
		gwinfo.ck_enabled = 0;
		gwinfo.xpos = cam->win.w.left;
		gwinfo.ypos = cam->win.w.top;
		gwinfo.xres = cam->win.w.width;
		gwinfo.yres = cam->win.w.height;
		gwinfo.xres_virtual = cam->win.w.width;
		gwinfo.vs_reversed = 0;
		gwinfo.base = (unsigned long)cam->vf_bufs[g_vfbuf];
		mx2_gw_set(&gwinfo);

		g_vfbuf = g_vfbuf ? 0 : 1;
	}
}

/*
 * @brief Check if the resize ratio is supported based on the input and output
 *        dimension
 * @param	input	input dimension
 * @param	output	output dimension
 * @return	output dimension (should equal the parameter *output*)
 * 		-1 on failure
 */
static int check_simple(scale_t * scale, int input, int output)
{
	unsigned short int_out;	/* PrP internel width or height */
	unsigned short orig_out = output;

	if (prp_scale(scale, input, output, input, &orig_out, &int_out, 0))
		return -1;	/* resize failed */
	else
		return int_out;
}

/*
 * @brief Check if the resize ratio is supported based on the input and output
 *        dimension
 * @param	input	input dimension
 * @param	output	output dimension
 * @return	output dimension, may be rounded.
 * 		-1 on failure
 */
static int check_simple_retry(scale_t * scale, int input, int output)
{
	unsigned short int_out;	/* PrP internel width or height */
	unsigned short orig_out = output;

	if (prp_scale(scale, input, output, input, &orig_out, &int_out,
		      SCALE_RETRY))
		return -1;	/* resize failed */
	else
		return int_out;
}

/*!
 * @brief Check if the resize ratio is supported by PrP channel 1
 * @param cfg	Pointer to emma_prp_cfg structure
 * @return	Zero on success, others on failure
 */
static int prp_resize_check_ch1(emma_prp_cfg * cfg)
{
	int in_w, in_h, ch1_w, ch1_h, ch2_w, ch2_h, w, h;
	scale_t *pscale = &cfg->scale[0];	/* Ch1 width resize coeff */

	if (cfg->ch1_pix == PRP_PIX1_UNUSED)
		return 0;

	in_w = cfg->in_width;
	in_h = cfg->in_height;
	ch1_w = cfg->ch1_width;
	ch1_h = cfg->ch1_height;
	ch2_w = cfg->ch2_width;
	ch2_h = cfg->ch2_height;

	/*
	 * For channel 1, try parallel resize first. If the resize
	 * ratio is not exactly supported, try cascade resize. If it
	 * still fails, use parallel resize but with rounded value.
	 */
	w = check_simple(pscale, in_w, ch1_w);
	h = check_simple(pscale + 1, in_h, ch1_h);
	if ((w == ch1_w) && (h == ch1_h))
		goto exit_parallel;

	if (cfg->ch2_pix != PRP_PIX2_UNUSED) {
		/*
		 * Channel 2 is already used. The pscale is still pointing
		 * to ch1 resize coeff for temporary use.
		 */
		w = check_simple(pscale, in_w, ch2_w);
		h = check_simple(pscale + 1, in_h, ch2_h);
		if ((w == ch2_w) && (h == ch2_h)) {
			/* Try cascade resize now */
			w = check_simple(pscale, ch2_w, ch1_w);
			h = check_simple(pscale + 1, ch2_h, ch1_h);
			if ((w == ch1_w) && (h == ch1_h))
				goto exit_cascade;
		}
	} else {
		/*
		 * Try cascade resize for width, width is multiple of 2.
		 * Channel 2 is not used. So we have more values to pick
		 * for channel 2 resize.
		 */
		for (w = in_w - 2; w > ch1_w; w -= 2) {
			/* Ch2 width resize */
			if (check_simple(pscale + 2, in_w, w) != w)
				continue;
			/* Ch1 width resize */
			if (check_simple(pscale, w, ch1_w) != ch1_w)
				continue;
			break;
		}
		if ((ch2_w = w) > ch1_w) {
			/* try cascade resize for height */
			for (h = in_h - 1; h > ch1_h; h--) {
				/* Ch2 height resize */
				if (check_simple(pscale + 3, in_h, h) != h)
					continue;
				/* Ch1 height resize */
				if (check_simple(pscale + 1, h, ch1_h) != ch1_h)
					continue;
				break;
			}
			if ((ch2_h = h) > ch1_h)
				goto exit_cascade;
		}
	}

	/* Have to try parallel resize again and round the dimensions */
	w = check_simple_retry(pscale, in_w, ch1_w);
	h = check_simple_retry(pscale + 1, in_h, ch1_h);
	if ((w != -1) && (h != -1))
		goto exit_parallel;

	pr_debug("Ch1 resize error.\n");
	return -1;

      exit_parallel:
	cfg->ch1_scale.algo |= PRP_ALGO_BYPASS;
	pr_debug("ch1 parallel resize.\n");
	pr_debug("original width = %d internel width = %d\n", ch1_w, w);
	pr_debug("original height = %d internel height = %d\n", ch1_h, h);
	return 0;

      exit_cascade:
	cfg->ch1_scale.algo &= ~PRP_ALGO_BYPASS;
	pr_debug("ch1 cascade resize.\n");
	pr_debug("[width] in : ch2 : ch1=%d : %d : %d\n", in_w, ch2_w, ch1_w);
	pr_debug("[height] in : ch2 : ch1=%d : %d : %d\n", in_h, ch2_h, ch1_h);
	return 0;
}

/*!
 * @brief Check if the resize ratio is supported by PrP channel 2
 * @param cfg	Pointer to emma_prp_cfg structure
 * @return	Zero on success, others on failure
 */
static int prp_resize_check_ch2(emma_prp_cfg * cfg)
{
	int w, h;
	scale_t *pscale = &cfg->scale[2];	/* Ch2 width resize coeff */

	if (cfg->ch2_pix == PRP_PIX2_UNUSED)
		return 0;

	w = check_simple_retry(pscale, cfg->in_width, cfg->ch2_width);
	h = check_simple_retry(pscale + 1, cfg->in_height, cfg->ch2_height);
	if ((w != -1) && (h != -1)) {
		pr_debug("Ch2 resize.\n");
		pr_debug("Original width = %d internel width = %d\n",
			 cfg->ch2_width, w);
		pr_debug("Original height = %d internel height = %d\n",
			 cfg->ch2_height, h);
		return 0;
	} else {
		pr_debug("Ch2 resize error.\n");
		return -1;
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #
# Makefile for the Linux aic7xxx SCSI driver.
#
# $Id: //depot/linux-aic79xx-2.5.0/drivers/scsi/aic7xxx/Makefile#8 $
#

# Let kbuild descend into aicasm when cleaning
subdir-				+= aicasm

obj-$(CONFIG_SCSI_AIC7XXX)	+= aic7xxx.o
obj-$(CONFIG_SCSI_AIC79XX)	+= aic79xx.o

# Core Fast -> U160 files
aic7xxx-y					+= aic7xxx_core.o	\
						   aic7xxx_93cx6.o
aic7xxx-$(CONFIG_EISA)				+= aic7770.o
aic7xxx-$(CONFIG_PCI)				+= aic7xxx_pci.o
aic7xxx-$(CONFIG_AIC7XXX_REG_PRETTY_PRINT)	+= aic7xxx_reg_print.o

# Platform Specific Fast -> U160 Files
aic7xxx-y					+= aic7xxx_osm.o	\
						   aic7xxx_proc.o
aic7xxx-$(CONFIG_EISA)				+= aic7770_osm.o
aic7xxx-$(CONFIG_PCI)				+= aic7xxx_osm_pci.o

# Core U320 files
aic79xx-y					+= aic79xx_core.o	\
						   aic79xx_pci.o
aic79xx-$(CONFIG_AIC79XX_REG_PRETTY_PRINT)	+= aic79xx_reg_print.o

# Platform Specific U320 Files
aic79xx-y					+= aic79xx_osm.o	\
						   aic79xx_proc.o	\
						   aic79xx_osm_pci.o

ccflags-y += -Idrivers/scsi
ifdef WARNINGS_BECOME_ERRORS
ccflags-y += -Werror
endif

# Files generated that shall be removed upon make clean
clean-files := aic7xxx_seq.h aic7xxx_reg.h aic7xxx_reg_print.c
clean-files += aic79xx_seq.h aic79xx_reg.h aic79xx_reg_print.c

# Dependencies for generated files need to be listed explicitly

$(addprefix $(obj)/,$(aic7xxx-y)): $(obj)/aic7xxx_seq.h $(obj)/aic7xxx_reg.h
$(addprefix $(obj)/,$(aic79xx-y)): $(obj)/aic79xx_seq.h $(obj)/aic79xx_reg.h

aic7xxx-gen-$(CONFIG_AIC7XXX_BUILD_FIRMWARE)	:= $(obj)/aic7xxx_reg.h
aic7xxx-gen-$(CONFIG_AIC7XXX_REG_PRETTY_PRINT)	+= $(obj)/aic7xxx_reg_print.c

aicasm-7xxx-opts-$(CONFIG_AIC7XXX_REG_PRETTY_PRINT) := \
	-p $(obj)/aic7xxx_reg_print.c -i aic7xxx_osm.h

ifeq ($(CONFIG_AIC7XXX_BUILD_FIRMWARE),y)
$(obj)/aic7xxx_seq.h: $(src)/aic7xxx.seq $(src)/aic7xxx.reg $(obj)/aicasm/aicasm
	$(obj)/aicasm/aicasm -I$(src) -r $(obj)/aic7xxx_reg.h \
			      $(aicasm-7xxx-opts-y) -o $(obj)/aic7xxx_seq.h \
			      $(src)/aic7xxx.seq

$(aic7xxx-gen-y): $(obj)/aic7xxx_seq.h
else
$(obj)/aic7xxx_reg_print.c: $(src)/aic7xxx_reg_print.c_shipped
endif

aic79xx-gen-$(CONFIG_AIC79XX_BUILD_FIRMWARE)	:= $(obj)/aic79xx_reg.h
aic79xx-gen-$(CONFIG_AIC79XX_REG_PRETTY_PRINT)	+= $(obj)/aic79xx_reg_print.c

aicasm-79xx-opts-$(CONFIG_AIC79XX_REG_PRETTY_PRINT) := \
	-p $(obj)/aic79xx_reg_print.c -i aic79xx_osm.h

ifeq ($(CONFIG_AIC79XX_BUILD_FIRMWARE),y)
$(obj)/aic79xx_seq.h: $(src)/aic79xx.seq $(src)/aic79xx.reg $(obj)/aicasm/aicasm
	$(obj)/aicasm/aicasm -I$(src) -r $(obj)/aic79xx_reg.h \
			      $(aicasm-79xx-opts-y) -o $(obj)/aic79xx_seq.h \
			      $(src)/aic79xx.seq

$(aic79xx-gen-y): $(obj)/aic79xx_seq.h
else
$(obj)/aic79xx_reg_print.c: $(src)/aic79xx_reg_print.c_shipped
endif

$(obj)/aicasm/aicasm: $(src)/aicasm/*.[chyl]
	$(MAKE) -C $(src)/aicasm
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         