		 */
					if (has_leaning_key) {
						scancode =
						    mxc_scan_matrix_leaning_key
						    (row, col, 1);
					} else {
						scancode =
						    ((row * kpp_dev.kpp_cols) +
						     col);
						KPress = 1;
						kpp_dev.iKeyState = KStateUp;
					}
					pr_debug("Press   (%d, %d) scan=%d "
						 "Kpress=%d\n",
						 row, col, scancode, KPress);
					press_scancode[row][col] =
					    (short)scancode;
				} else {
					/*
					 * Previous state is not 0, so
					 * now a key is released
					 */
					if (has_leaning_key) {
						scancode =
						    mxc_scan_matrix_leaning_key
						    (row, col, 0);
					} else {
						scancode =
						    (row * kpp_dev.kpp_cols) +
						    col + MXC_KEYRELEASE;
						KPress = 0;
						kpp_dev.iKeyState = KStateDown;
					}

					pr_debug
					    ("Release (%d, %d) scan=%d Kpress=%d\n",
					     row, col, scancode, KPress);
					release_scancode[row][col] =
					    (short)scancode;
					keycnt++;
				}
			}
		}
	}

	/*
	 * This switch case statement is the
	 * implementation of state machine of debounce
	 * logic for key press/release.
	 * The explaination of state machine is as
	 * follows:
	 *
	 * KStateUp State:
	 * This is in intial state of the state machine
	 * this state it checks for any key presses.
	 * The key press can be checked using the
	 * variable KPress. If KPress is set, then key
	 * press is identified and switches the to
	 * KStateFirstDown state for key press to
	 * debounce.
	 *
	 * KStateFirstDown:
	 * After debounce delay(10ms), if the KPress is
	 * still set then pass scancode generated to
	 * input device and change the state to
	 * KStateDown, else key press debounce is not
	 * satisfied so change the state to KStateUp.
	 *
	 * KStateDown:
	 * In this state it checks for any key release.
	 * If KPress variable is cleared, then key
	 * release is indicated and so, switch the
	 * state to KStateFirstUp else to state
	 * KStateDown.
	 *
	 * KStateFirstUp:
	 * After debounce delay(10ms), if the KPress is
	 * still reset then pass the key release
	 * scancode to input device and change
	 * the state to KStateUp else key release is
	 * not satisfied so change the state to
	 * KStateDown.
	 */
	switch (kpp_dev.iKeyState) {
	case KStateUp:
		if (KPress) {
			/* First Down (must debounce). */
			kpp_dev.iKeyState = KStateFirstDown;
		} else {
			/* Still UP.(NO Changes) */
			kpp_dev.iKeyState = KStateUp;
		}
		break;

	case KStateFirstDown:
		if (KPress) {
			for (row = 0; row < kpp_dev.kpp_rows; row++) {
				for (col = 0; col < kpp_dev.kpp_cols; col++) {
					if ((press_scancode[row][col] != -1)) {
						/* Still Down, so add scancode */
						scancode =
						    press_scancode[row][col];
						input_event(mxckbd_dev, EV_KEY,
							    mxckpd_keycodes
							    [scancode], 1);
						if (mxckpd_keycodes[scancode] ==
						    KEY_LEFTSHIFT) {
							input_event(mxckbd_dev,
								    EV_KEY,
								    KEY_3, 1);
						}
						kpp_dev.iKeyState = KStateDown;
						press_scancode[row][col] = -1;
					}
				}
			}

			if(SAND_PS4K==sand_machine())
			{
				iowrite8(0x01,kpp_dev.kpp_buzzer);
				iowrite8(0x0A,kpp_dev.kpp_light);
			}
			else if(SAND_IPS420==sand_machine())
			{

			    Beep_Backlight_On();
			}


		} else {
			/* Just a bounce */
			kpp_dev.iKeyState = KStateUp;
		}
		break;

	case KStateDown:
		if (KPress) {
			/* Still down (no change) */
			kpp_dev.iKeyState = KStateDown;
		} else {
			/* First Up. Must debounce */
			kpp_dev.iKeyState = KStateFirstUp;
		}
		break;

	case KStateFirstUp:
		if (KPress) {
			/* Just a bounce */
			kpp_dev.iKeyState = KStateDown;
		} else {
			for (row = 0; row < kpp_dev.kpp_rows; row++) {
				for (col = 0; col < kpp_dev.kpp_cols; col++) {
					if ((release_scancode[row][col] != -1)) {
						scancode =
						    release_scancode[row][col];
						scancode =
						    scancode - MXC_KEYRELEASE;
						input_event(mxckbd_dev, EV_KEY,
							    mxckpd_keycodes
							    [scancode], 0);
						if (mxckpd_keycodes[scancode] ==
						    KEY_LEFTSHIFT) {
							input_event(mxckbd_dev,
								    EV_KEY,
								    KEY_3, 0);
						}
						kpp_dev.iKeyState = KStateUp;
						release_scancode[row][col] = -1;
					}
				}
			}

		}
		break;

	default:
		return -EBADRQC;
		break;
	}

	return keycnt;
}

/*!
 * This function is called to start the timer for scanning the keypad if there
 * is any key press. Currently this interval is  set to 10 ms. When there are
 * no keys pressed on the keypad we return back, waiting for a keypad key
 * press interrupt.
 *
 * @param data  Opaque data passed back by kernel. Not used.
 */
static void mxc_kpp_handle_timer(unsigned long data)
{
	unsigned short reg_val;
	int i;

	if (key_pad_enabled == 0) {
		return;
	}
	if (mxc_kpp_scan_matrix() == 0) {
		/*
		 * Stop scanning and wait for interrupt.
		 * Enable press interrupt and disable release interrupt.
		 */
		__raw_writew(0x00FF, KPDR);
		reg_val = __raw_readw(KPSR);
		reg_val |= (KBD_STAT_KPKR | KBD_STAT_KPKD);
		reg_val |= KBD_STAT_KRSS | KBD_STAT_KDSC;
		__raw_writew(reg_val, KPSR);
		reg_val |= KBD_STAT_KDIE;
		reg_val &= ~KBD_STAT_KRIE;
		__raw_writew(reg_val, KPSR);

		/*
		 * No more keys pressed... make sure unwanted key codes are
		 * not given upstairs
		 */
		for (i = 0; i < kpp_dev.kpp_rows; i++) {
			memset(press_scancode[i], -1,
			       sizeof(press_scancode[0][0]) * kpp_dev.kpp_cols);
			memset(release_scancode[i], -1,
			       sizeof(release_scancode[0][0]) *
			       kpp_dev.kpp_cols);
		}
		return;
	}

	/*
	 * There are still some keys pressed, continue to scan.
	 * We shall scan again in 10 ms. This has to be tuned according
	 * to the requirement.
	 */
	kpp_dev.poll_timer.expires = jiffies + KScanRate;
	kpp_dev.poll_timer.function = mxc_kpp_handle_timer;
	add_timer(&kpp_dev.poll_timer);
}

/*!
 * This function is the keypad Interrupt handler.
 * This function checks for keypad status register (KPSR) for key press
 * and interrupt. If key press interrupt has occurred, then the key
 * press interrupt in the KPSR are disabled.
 * It then calls mxc_kpp_scan_matrix to check for any key pressed/released.
 * If any key is found to be pressed, then a timer is set to call
 * mxc_kpp_scan_matrix function for every 10 ms.
 *
 * @param   irq      The Interrupt number
 * @param   dev_id   Driver private data
 *
 * @result    The function returns \b IRQ_RETVAL(1) if interrupt was handled,
 *            returns \b IRQ_RETVAL(0) if the interrupt was not handled.
 *            \b IRQ_RETVAL is defined in include/linux/interrupt.h.
 */
static irqreturn_t mxc_kpp_interrupt(int irq, void *dev_id)
{
	unsigned short reg_val;
	pr_debug("irq\n");

	/* Delete the polling timer */
	del_timer(&kpp_dev.poll_timer);
	reg_val = __raw_readw(KPSR);

	/* Check if it is key press interrupt */
	if (reg_val & KBD_STAT_KPKD) {
		/*
		 * Disable key press(KDIE status bit) interrupt
		 */
		reg_val &= ~KBD_STAT_KDIE;
		__raw_writew(reg_val, KPSR);
	} else {
		/* spurious interrupt */
		return IRQ_RETVAL(0);
	}
	/*
	 * Check if any keys are pressed, if so start polling.
	 */
	mxc_kpp_handle_timer(0);

	return IRQ_RETVAL(1);
}

/*!
 * This function is called when the keypad driver is opened.
 * Since keypad initialization is done in __init, nothing is done in open.
 *
 * @param    dev    Pointer to device inode
 *
 * @result    The function always return 0
 */
static int mxc_kpp_open(struct input_dev *dev)
{
	return 0;
}

/*!
 * This function is called close the keypad device.
 * Nothing is done in this function, since every thing is taken care in
 * __exit function.
 *
 * @param    dev    Pointer to device inode
 *
 */
static void mxc_kpp_close(struct input_dev *dev)
{
}

#ifdef CONFIG_PM
/*!
 * This function puts the Keypad controller in low-power mode/state.
 * If Keypad is enabled as a wake source(i.e. it can resume the system
 * from suspend mode), the Keypad controller doesn't enter low-power state.
 *
 * @param   pdev  the device structure used to give information on Keypad
 *                to suspend
 * @param   state the power state the device is entering
 *
 * @return  return -1 when the keypad is pressed. Otherwise, return 0
 */
static int montiguous
region of memory and holds tp_block_size/tp_frame_size frames. The total number 
of blocks is tp_block_nr. Note that tp_frame_nr is a redundant parameter because

    frames_per_block = tp_block_size/tp_frame_size

indeed, packet_set_ring checks that the following condition is true

    frames_per_block * tp_block_nr == tp_frame_nr


Lets see an example, with the following values:

     tp_block_size= 4096
     tp_frame_size= 2048
     tp_block_nr  = 4
     tp_frame_nr  = 8

we will get the following buffer structure:

        block #1                 block #2         
+---------+---------+    +---------+---------+    
| frame 1 | frame 2 |    | frame 3 | frame 4 |    
+---------+---------+    +---------+---------+    

        block #3                 block #4
+---------+---------+    +---------+---------+
| frame 5 | frame 6 |    | frame 7 | frame 8 |
+---------+---------+    +---------+---------+

A frame can be of any size with the only condition it can fit in a block. A block
can only hold an integer number of frames, or in other words, a frame cannot 
be spawned accross two blocks, so there are some details you have to take into 
account when choosing the frame_size. See "Mapping and use of the circular 
buffer (ring)".


--------------------------------------------------------------------------------
+ PACKET_MMAP setting constraints
--------------------------------------------------------------------------------

In kernel versions prior to 2.4.26 (for the 2.4 branch) and 2.6.5 (2.6 branch),
the PACKET_MMAP buffer could hold only 32768 frames in a 32 bit architecture or
16384 in a 64 bit architecture. For information on these kernel versions
see http://pusa.uv.es/~ulisses/packet_mmap/packet_mmap.pre-2.4.26_2.6.5.txt

 Block size limit
------------------

As stated earlier, each block is a contiguous physical region of memory. These 
memory regions are allocated with calls to the __get_free_pages() function. As 
the name indicates, this function allocates pages of memory, and the second
argument is "order" or a power of two number of pages, that is 
(for PAGE_SIZE == 4096) order=0 ==> 4096 bytes, order=1 ==> 8192 bytes, 
order=2 ==> 16384 bytes, etc. The maximum size of a 
region allocated by __get_free_pages is determined by the MAX_ORDER macro. More 
precisely the limit can be calculated as:

   PAGE_SIZE << MAX_ORDER

   In a i386 architecture PAGE_SIZE is 4096 bytes 
   In a 2.4/i386 kernel MAX_ORDER is 10
   In a 2.6/i386 kernel MAX_ORDER is 11

So get_free_pages can allocate as much as 4MB or 8MB in a 2.4/2.6 kernel 
respectively, with an i386 architecture.

User space programs can include /usr/include/sys/user.h and 
/usr/include/linux/mmzone.h to get PAGE_SIZE MAX_ORDER declarations.

The pagesize can also be determined dynamically with the getpagesize (2) 
system call. 


 Block number limit
--------------------

To understand the constraints of PACKET_MMAP, we have to see the structure 
used to hold the pointers to each block.

Currently, this structure is a dynamically allocated vector with kmalloc 
called pg_vec, its size limits the number of blocks that can be allocated.

    +---+---+---+---+
    | x | x | x | x |
    +---+---+---+---+
      |   |   |   |
      |   |   |   v
      |   |   v  block #4
      |   v  block #3
      v  block #2
     block #1


kmalloc allocates any number of bytes of physically contiguous memory from 
a pool of pre-determined sizes. This pool of memory is maintained by the slab 
allocator which is at the end the responsible for doing the allocation and 
hence which imposes the maximum memory that kmalloc can allocate. 

In a 2.4/2.6 kernel and the i386 architecture, the limit is 131072 bytes. The 
predetermined sizes that kmalloc uses can be checked in the "size-<bytes>" 
entries of /proc/slabinfo

In a 32 bit architecture, pointers are 4 bytes long, so the total number of 
pointers to blocks is

     131072/4 = 32768 blocks


 PACKET_MMAP buffer size calculator
------------------------------------

Definitions:

<size-max>    : is the maximum size of allocable with kmalloc (see /proc/slabinfo)
<pointer size>: depends on the architecture -- sizeof(void *)
<page size>   : depends on the architecture -- PAGE_SIZE or getpagesize (2)
<max-order>   : is the value defined with MAX_ORDER
<frame size>  : it's an upper bound of frame's capture size (more on this later)

from these definitions we will derive 

	<block number> = <size-max>/<pointer size>
	<block size> = <pagesize> << <max-order>

so, the max buffer size is

	<block number> * <block size>

and, the number of frames be

	<block number> * <block size> / <frame size>

Suppose the following parameters, which apply for 2.6 kernel and an
i386 architecture:

	<size-max> = 131072 bytes
	<pointer size> = 4 bytes
	<pagesize> = 4096 bytes
	<max-order> = 11

and a value for <frame size> of 2048 bytes. These parameters will yield

	<block number> = 131072/4 = 32768 blocks
	<block size> = 4096 << 11 = 8 MiB.

and hence the buffer will have a 262144 MiB size. So it can hold 
262144 MiB / 2048 bytes = 134217728 frames


Actually, this buffer size is not possible with an i386 architecture. 
Remember that the memory is allocated in kernel space, in the case of 
an i386 kernel's memory size is limited to 1GiB.

All memory allocations are not freed until the socket is closed. The memory 
allocations are done with GFP_KERNEL priority, this basically means that 
the allocation can wait and swap other process' memory in order to allocate 
the necessary memory, so normally limits can be reached.

 Other constraints
-------------------

If you check the source code you will see that what I draw here as a frame
is not only the link level frame. At the beginning of each frame there is a 
header called struct tpacket_hdr used in PACKET_MMAP to hold link level's frame
meta information like timestamp. So what we draw here a frame it's really 
the following (from include/linux/if_packet.h):

/*
   Frame structure:

   - Start. Frame must be aligned to TPACKET_ALIGNMENT=16
   - struct tpacket_hdr
   - pad to TPACKET_ALIGNMENT=16
   - struct sockaddr_ll
   - Gap, chosen so that packet data (Start+tp_net) aligns to 
     TPACKET_ALIGNMENT=16
   - Start+tp_mac: [ Optional MAC header ]
   - Start+tp_net: Packet data, aligned to TPACKET_ALIGNMENT=16.
   - Pad to align to TPACKET_ALIGNMENT=16
 */
           
 
 The following are conditions that are checked in packet_set_ring

   tp_block_size must be a multiple of PAGE_SIZE (1)
   tp_frame_size must be greater than TPACKET_HDRLEN (obvious)
   tp_frame_size must be a multiple of TPACKET_ALIGNMENT
   tp_frame_nr   must be exactly frames_per_block*tp_block_nr

Note that tp_block_size should be chosen to be a power of two or there will
be a waste of memory.

--------------------------------------------------------------------------------
+ Mapping and use of the circular buffer (ring)
--------------------------------------------------------------------------------

The mapping of the buffer in the user process is done with the conventional 
mmap function. Even the circular buffer is compound of several physically
discontiguous blocks of memory, they are contiguous to the user space, hence
just one call to mmap is needed:

    mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);

If tp_frame_size is a divisor of tp_block_size frames will be 
contiguously spaced by tp_frame_size bytes. If not, each
tp_block_size/tp_frame_size frames there will be a gap between 
the frames. This is because a frame cannot be spawn across two
blocks. 

At the beginning of each frame there is an status field (see 
struct tpacket_hdr). If this field is 0 means that the frame is ready
to be used for the kernel, If not, there is a frame the user can read 
and the following flags apply:

+++ Capture process:
     from include/linux/if_packet.h

     #define TP_STATUS_COPY          2 
     #define TP_STATUS_LOSING        4 
     #define TP_STATUS_CSUMNOTREADY  8 


TP_STATUS_COPY        : This flag indicates that the frame (and associated
                        meta information) has been truncated because it's 
                        larger than tp_frame_size. This packet can be 
                        read entirely with recvfrom().
                        
                        In order to make this work it must to be
                        enabled previously with setsockopt() and 
                        the PACKET_COPY_THRESH option. 

                        The number of frames than can be buffered to 
                        be read with recvfrom is limited like a normal socket.
                        See the SO_RCVBUF option in the socket (7) man page.

TP_STATUS_LOSING      : indicates there were packet drops from last time 
                        statistics where checked with getsockopt() and
                        the PACKET_STATISTICS option.

TP_STATUS_CSUMNOTREADY: currently it's used for outgoing IP packets which 
                        it's checksum will be done in hardware. So while 
                        reading the packet we should not try to check the 
                        checksum. 

for convenience there are also the following defines:

     #define TP_STATUS_KERNEL        0
     #define TP_STATUS_USER          1

The kernel initializes all frames to TP_STATUS_KERNEL, when the kernel
receives a packet it puts in the buffer and updates the status with
at least the TP_STATUS_USER flag. Then the user can read the packet,
once the packet is read the user must zero the status field, so the kernel 
can use again that frame buffer.

The user can use poll (any other variant should apply too) to check if new
packets are in the ring:

    struct pollfd pfd;

    pfd.fd = fd;
    pfd.revents = 0;
    pfd.events = POLLIN|POLLRDNORM|POLLERR;

    if (status == TP_STATUS_KERNEL)
        retval = poll(&pfd, 1, timeout);

It doesn't incur in a race condition to first check the status value and 
then poll for frames.


++ Transmission process
Those defines are also used for transmission:

     #define TP_STATUS_AVAILABLE        0 // Frame is available
     #define TP_STATUS_SEND_REQUEST     1 // Frame will be sent on next send()
     #define TP_STATUS_SENDING          2 // Frame is currently in transmission
     #define TP_STATUS_WRONG_FORMAT     4 // Frame format is not correct

First, the kernel initializes all frames to TP_STATUS_AVAILABLE. To send a
packet, the user fills a data buffer of an available frame, sets tp_len to
current data buffer size and sets its status field to TP_STATUS_SEND_REQUEST.
This can be done on multiple frames. Once the user is ready to transmit, it
calls send(). Then all buffers with status equal to TP_STATUS_SEND_REQUEST are
forwarded to the network device. The kernel updates each status of sent
frames with TP_STATUS_SENDING until the end of transfer.
At the end of each transfer, buffer status returns to TP_STATUS_AVAILABLE.

    header->tp_len = in_i_size;
    header->tp_status = TP_STATUS_SEND_REQUEST;
    retval = send(this->socket, NULL, 0, 0);

The user can also use poll() to check if a buffer is available:
(status == TP_STATUS_SENDING)

    struct pollfd pfd;
    pfd.fd = fd;
    pfd.revents = 0;
    pfd.events = POLLOUT;
    retval = poll(&pfd, 1, timeout);

--------------------------------------------------------------------------------
+ THANKS
--------------------------------------------------------------------------------
   
   Jesse Brandeburg, for fixing my grammathical/spelling errors

