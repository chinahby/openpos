0_DIVISOR);
	hw->vga1_divisor = INREG(VGA1_DIVISOR);
	hw->vga_pd = INREG(VGAPD);
	hw->dpll_a = INREG(DPLL_A);
	hw->dpll_b = INREG(DPLL_B);
	hw->fpa0 = INREG(FPA0);
	hw->fpa1 = INREG(FPA1);
	hw->fpb0 = INREG(FPB0);
	hw->fpb1 = INREG(FPB1);

	if (flag == 1)
		return flag;

#if 0
	/* This seems to be a problem with the 852GM/855GM */
	for (i = 0; i < PALETTE_8_ENTRIES; i++) {
		hw->palette_a[i] = INREG(PALETTE_A + (i << 2));
		hw->palette_b[i] = INREG(PALETTE_B + (i << 2));
	}
#endif

	if (flag == 2)
		return flag;

	hw->htotal_a = INREG(HTOTAL_A);
	hw->hblank_a = INREG(HBLANK_A);
	hw->hsync_a = INREG(HSYNC_A);
	hw->vtotal_a = INREG(VTOTAL_A);
	hw->vblank_a = INREG(VBLANK_A);
	hw->vsync_a = INREG(VSYNC_A);
	hw->src_size_a = INREG(SRC_SIZE_A);
	hw->bclrpat_a = INREG(BCLRPAT_A);
	hw->htotal_b = INREG(HTOTAL_B);
	hw->hblank_b = INREG(HBLANK_B);
	hw->hsync_b = INREG(HSYNC_B);
	hw->vtotal_b = INREG(VTOTAL_B);
	hw->vblank_b = INREG(VBLANK_B);
	hw->vsync_b = INREG(VSYNC_B);
	hw->src_size_b = INREG(SRC_SIZE_B);
	hw->bclrpat_b = INREG(BCLRPAT_B);

	if (flag == 3)
		return flag;

	hw->adpa = INREG(ADPA);
	hw->dvoa = INREG(DVOA);
	hw->dvob = INREG(DVOB);
	hw->dvoc = INREG(DVOC);
	hw->dvoa_srcdim = INREG(DVOA_SRCDIM);
	hw->dvob_srcdim = INREG(DVOB_SRCDIM);
	hw->dvoc_srcdim = INREG(DVOC_SRCDIM);
	hw->lvds = INREG(LVDS);

	if (flag == 4)
		return flag;

	hw->pipe_a_conf = INREG(PIPEACONF);
	hw->pipe_b_conf = INREG(PIPEBCONF);
	hw->disp_arb = INREG(DISPARB);

	if (flag == 5)
		return flag;

	hw->cursor_a_control = INREG(CURSOR_A_CONTROL);
	hw->cursor_b_control = INREG(CURSOR_B_CONTROL);
	hw->cursor_a_base = INREG(CURSOR_A_BASEADDR);
	hw->cursor_b_base = INREG(CURSOR_B_BASEADDR);

	if (flag == 6)
		return flag;

	for (i = 0; i < 4; i++) {
		hw->cursor_a_palette[i] = INREG(CURSOR_A_PALETTE0 + (i << 2));
		hw->cursor_b_palette[i] = INREG(CURSOR_B_PALETTE0 + (i << 2));
	}

	if (flag == 7)
		return flag;

	hw->cursor_size = INREG(CURSOR_SIZE);

	if (flag == 8)
		return flag;

	hw->disp_a_ctrl = INREG(DSPACNTR);
	hw->disp_b_ctrl = INREG(DSPBCNTR);
	hw->disp_a_base = INREG(DSPABASE);
	hw->disp_b_base = INREG(DSPBBASE);
	hw->disp_a_stride = INREG(DSPASTRIDE);
	hw->disp_b_stride = INREG(DSPBSTRIDE);

	if (flag == 9)
		return flag;

	hw->vgacntrl = INREG(VGACNTRL);

	if (flag == 10)
		return flag;

	hw->add_id = INREG(ADD_ID);

	if (flag == 11)
		return flag;

	for (i = 0; i < 7; i++) {
		hw->swf0x[i] = INREG(SWF00 + (i << 2));
		hw->swf1x[i] = INREG(SWF10 + (i << 2));
		if (i < 3)
			hw->swf3x[i] = INREG(SWF30 + (i << 2));
	}

	for (i = 0; i < 8; i++)
		hw->fence[i] = INREG(FENCE + (i << 2));

	hw->instpm = INREG(INSTPM);
	hw->mem_mode = INREG(MEM_MODE);
	hw->fw_blc_0 = INREG(FW_BLC_0);
	hw->fw_blc_1 = INREG(FW_BLC_1);

	hw->hwstam = INREG16(HWSTAM);
	hw->ier = INREG16(IER);
	hw->iir = INREG16(IIR);
	hw->imr = INREG16(IMR);

	return 0;
}


static int calc_vclock3(int index, int m, int n, int p)
{
	if (p == 0 || n == 0)
		return 0;
	return plls[index].ref_clk * m / n / p;
}

static int calc_vclock(int index, int m1, int m2, int n, int p1, int p2,
		       int lvds)
{
	struct pll_min_max *pll = &plls[index];
	u32 m, vco, p;

	m = (5 * (m1 + 2)) + (m2 + 2);
	n += 2;
	vco = pll->ref_clk * m / n;

	if (index == PLLS_I8xx)
		p = ((p1 + 2) * (1 << (p2 + 1)));
	else
		p = ((p1) * (p2 ? 5 : 10));
	return vco / p;
}

#if REGDUMP
static void intelfbhw_get_p1p2(struct intelfb_info *dinfo, int dpll,
			       int *o_p1, int *o_p2)
{
	int p1, p2;

	if (IS_I9XX(dinfo)) {
		if (dpll & DPLL_P1_FORCE_DIV2)
			p1 = 1;
		else
			p1 = (dpll >> DPLL_P1_SHIFT) & 0xff;

		p1 = ffs(p1);

		p2 = (dpll >> DPLL_I9XX_P2_SHIFT) & DPLL_P2_MASK;
	} else {
		if (dpll & DPLL_P1_FORCE_DIV2)
			p1 = 0;
		else
			p1 = (dpll >> DPLL_P1_SHIFT) & DPLL_P1_MASK;
		p2 = (dpll >> DPLL_P2_SHIFT) & DPLL_P2_MASK;
	}

	*o_p1 = p1;
	*o_p2 = p2;
}
#endif


void intelfbhw_print_hw_state(struct intelfb_info *dinfo,
			      struct intelfb_hwstate *hw)
{
#if REGDUMP
	int i, m1, m2, n, p1, p2;
	int index = dinfo->pll_index;
	DBG_MSG("intelfbhw_print_hw_state\n");

	if (!hw)
		return;
	/* Read in as much of the HW state as possible. */
	printk("hw state dump start\n");
	printk("	VGA0_DIVISOR:		0x%08x\n", hw->vga0_divisor);
	printk("	VGA1_DIVISOR:		0x%08x\n", hw->vga1_divisor);
	printk("	VGAPD:			0x%08x\n", hw->vga_pd);
	n = (hw->vga0_divisor >> FP_N_DIVISOR_SHIFT) & FP_DIVISOR_MASK;
	m1 = (hw->vga0_divisor >> FP_M1_DIVISOR_SHIFT) & FP_DIVISOR_MASK;
	m2 = (hw->vga0_divisor >> FP_M2_DIVISOR_SHIFT) & FP_DIVISOR_MASK;

	intelfbhw_get_p1p2(dinfo, hw->vga_pd, &p1, &p2);

	printk("	VGA0: (m1, m2, n, p1, p2) = (%d, %d, %d, %d, %d)\n",
	       m1, m2, n, p1, p2);
	printk("	VGA0: clock is %d\n",
	       calc_vclock(index, m1, m2, n, p1, p2, 0));

	n = (hw->vga1_divisor >> FP_N_DIVISOR_SHIFT) & FP_DIVISOR_MASK;
	m1 = (hw->vga1_divisor >> FP_M1_DIVISOR_SHIFT) & FP_DIVISOR_MASK;
	m2 = (hw->vga1_divisor >> FP_M2_DIVISOR_SHIFT) & FP_DIVISOR_MASK;

	intelfbhw_get_p1p2(dinfo, hw->vga_pd, &p1, &p2);
	printk("	VGA1: (m1, m2, n, p1, p2) = (%d, %d, %d, %d, %d)\n",
	       m1, m2, n, p1, p2);
	printk("	VGA1: clock is %d\n",
	       calc_vclock(index, m1, m2, n, p1, p2, 0));

	printk("	DPLL_A:			0x%08x\n", hw->dpll_a);
	printk("	DPLL_B:			0x%08x\n", hw->dpll_b);
	printk("	FPA0:			0x%08x\n", hw->fpa0);
	printk("	FPA1:			0x%08x\n", hw->fpa1);
	printk("	FPB0:			0x%08x\n", hw->fpb0);
	printk("	FPB1:			0x%08x\n", hw->fpb1);

	n = (hw->fpa0 >> FP_N_DIVISOR_SHIFT) & FP_DIVISOR_MASK;
	m1 = (hw->fpa0 >> FP_M1_DIVISOR_SHIFT) & FP_DIVISOR_MASK;
	m2 = (hw->fpa0 >> FP_M2_DIVISOR_SHIFT) & FP_DIVISOR_MASK;

	intelfbhw_get_p1p2(dinfo, hw->dpll_a, &p1, &p2);

	printk("	PLLA0: (m1, m2, n, p1, p2) = (%d, %d, %d, %d, %d)\n",
	       m1, m2, n, p1, p2);
	printk("	PLLA0: clock is %d\n",
	       calc_vclock(index, m1, m2, n, p1, p2, 0));

	n = (hw->f