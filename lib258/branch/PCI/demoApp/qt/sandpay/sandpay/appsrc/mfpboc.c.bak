onst char *__restrict __file,
		    struct stat64 *__restrict __buf)
     __THROW __nonnull ((1, 2));
# endif
#endif

/* Set file access permissions for FILE to MODE.
   If FILE is a symbolic link, this affects its target instead.  */
extern int chmod (__const char *__file, __mode_t __mode)
     __THROW __nonnull ((1));

#ifdef __USE_BSD
/* Set file access permissions for FILE to MODE.
   If FILE is a symbolic link, this affects the link itself
   rather than its target.  */
extern int lchmod (__const char *__file, __mode_t __mode)
     __THROW __nonnull ((1));
#endif

/* Set file access permissions of the file FD is open on to MODE.  */
#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
extern int fchmod (int __fd, __mode_t __mode) __THROW;
#endif

#ifdef __USE_ATFILE
/* Set file access permissions of FILE relative to
   the directory FD is open on.  */
extern int fchmodat (int __fd, __const char *__file, __mode_t __mode,
		     int __flag)
     __THROW __nonnull ((2)) __wur;
#endif /* Use ATFILE.  */



/* Set the file creation mask of the current process to MASK,
   and return the old creation mask.  */
extern __mode_t umask (__mode_t __mask) __THROW;

#ifdef	__USE_GNU
/* Get the current `umask' value without changing it.
   This function is only available under the GNU Hurd.  */
extern __mode_t getumask (void) __THROW;
#endif

/* Create a new directory named PATH, with permission bits MODE.  */
extern int mkdir (__const char *__path, __mode_t __mode)
     __THROW __nonnull ((1));

#ifdef __USE_ATFILE
/* Like mkdir, create a new directory with permission bits MODE.  But
   interpret relative PATH names relative to the directory associated
   with FD.  */
extern int mkdirat (int __fd, __const char *__path, __mode_t __mode)
     __THROW __nonnull ((2));
#endif

/* Create a device file named PATH, with permission and special bits MODE
   and device number DEV (which can be constructed from major and minor
   device numbers with the `makedev' macro above).  */
#if defined __USE_MISC || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
extern int mknod (__const char *__path, __mode_t __mode, __dev_t __dev)
     __THROW __nonnull ((1));

# ifdef __USE_ATFILE
/* Like mknod, create a new device file with permission bits MODE and
   device number DEV.  But interpret relative PATH names relative to
   the directory associated with FD.  */
extern int mknodat (int __fd, __const char *__path, __mode_t __mode,
		    __dev_t __dev) __THROW __nonnull ((2));
# endif
#endif


/* Create a new FIFO named PATH, with permission bits MODE.  */
extern int mkfifo (__const char *__path, __mode_t __mode)
     __THROW __nonnull ((1));

#ifdef __USE_ATFILE
/* Like mkfifo, create a new FIFO with permission bits MODE.  But
   interpret relative PATH names relative to the directory associated
   with FD.  */
extern int mkfifoat (int __fd, __const char *__path, __mode_t __mode)
     __THROW __nonnull ((2));
#endif

#ifdef __USE_ATFILE
/* Set file access and modification times relative to directory file
   descriptor.  */
extern int utimensat (int __fd, __const char *__path,
		      __const struct timespec __times[2],
		      int __flags)
     __THROW __nonnull ((2));
#endif

#ifdef __USE_XOPEN2K8
/* Set file access and modification times of the file associated with FD.  */
extern int futimens (int __fd, __const struct timespec __times[2]) __THROW;
#endif

/* To allow the `struct stat' structure and the file type `mode_t'
   bits to vary without changing shared library major version number,
   the `stat' family of functions and `mknod' are in fact inline
   wrappers around calls to `xstat', `fxstat', `lxstat', and `xmknod',
   which all take a leading version-number argument designating the
   data structure and bits used.  <bits/stat.h> defines _STAT_VER with
   the version number corresponding to `struct stat' as defined in
   that file; and _MKNOD_VER with the version number corresponding to
   the S_IF* macros defined therein.  It is arranged that when not
   inlined these function are always statically linked; that );
	if( (ucResult = MIFARE_ISO(
						(unsigned char *)&Iso7816In,
						Iso7816Out.aucData,
						&Iso7816Out.uiLen,
						MIFARE_TYPE2)) != OK)
		return(ucResult);
    return(MIFARE_ISOCheckReturn());
}

unsigned char MIFARE_ISOLock(unsigned char *pucMacData)
{
	unsigned char	ucResult;

	Iso7816In.ucCla = 0x84;
	Iso7816In.ucIns = 0xcd;
	Iso7816In.ucP1  = 0x00;
	Iso7816In.ucP2  = 0x00;
	Iso7816In.ucP3  = 0x04;
	
	memcpy(&Iso7816In.aucDataIn[0],pucMacData,Iso7816In.ucP3);

	MIFARE_SetIso7816Out();
	if( (ucResult = MIFARE_ISO(
						(unsigned char *)&Iso7816In,
						Iso7816Out.aucData,
						&Iso7816Out.uiLen,
						MIFARE_TYPE3)) != OK)
		return(ucResult);
	return(MIFARE_ISOCheckReturn());

}

unsigned char MIFARE_ISOInitForPurchase(unsigned char ucType,unsigned char *pucInData)
{
	unsigned char	ucResult;

	Iso7816In.ucCla = 0x80;
	Iso7816In.ucIns = 0x50;
	Iso7816In.ucP1  = 0x01;
	Iso7816In.ucP2 = ucType;				/* 0x01 ED 0x02 EP */
	Iso7816In.ucP3  = 0x0B;

	memcpy(&Iso7816In.aucDataIn[0],pucInData,Iso7816In.ucP3);

	MIFARE_SetIso7816Out();
	if( (ucResult = MIFARE_ISO(
						(unsigned char *)&Iso7816In,
						Iso7816Out.aucData,
						&Iso7816Out.uiLen,
						MIFARE_TYPE3)) != OK)
		return(ucResult);
	return(MIFARE_ISOCheckReturn());
}

unsigned char MIFARE_ISODebit(unsigned char *pucDebitData,unsigned char ucLen)
{
	unsigned char	ucResult;

	Iso7816In.ucCla = 0x80;
	Iso7816In.ucIns = 0x54;
	Iso7816In.ucP1  = 0x01;
	Iso7816In.ucP2  = 0x00;
	Iso7816In.ucP3  = ucLen;
	
	memcpy(&Iso7816In.aucDataIn[0],pucDebitData,Iso7816In.ucP3);
	Iso7816In.aucDataIn[Iso7816In.ucP3] = 0x08;

	MIFARE_SetIso7816Out();
	if( (ucResult = MIFARE_ISO(
						(unsigned char *)&Iso7816In,
						Iso7816Out.aucData,
						&Iso7816Out.uiLen,
						MIFARE_TYPE3)) != OK)
		return(ucResult);
	return(MIFARE_ISOCheckReturn());

}

unsigned char MIFARE_ISOReadRecordbySFI(unsigned char ucSFI,unsigned char ucRecordNumber)
{
	unsigned char	ucResult;

	Iso7816In.ucCla = 0x00;
	Iso7816In.ucIns = 0xB2;
	Iso7816In.ucP1  = ucRecordNumber;
	Iso7816In.ucP2  = (ucSFI << 3) | 0x04;
	Iso7816In.ucP3  = 0x00;

	MIFARE_SetIso7816Out();
	if( (ucResult = MIFARE_ISO(
						(unsigned char *)&Iso7816In,
						Iso7816Out.aucData,
						&Iso7816Out.uiLen,
						MIFARE_TYPE2)) != OK)
		return(ucResult);
	return(MIFARE_ISOCheckReturn());
}
unsigned char MIFARE_ISOGetTac(unsigned char TranType,
			unsigned char *pucInData)
{
	unsigned char	ucResult;
	
	Iso7816In.ucCla = 0x80;
	Iso7816In.ucIns = 0x5A;
	Iso7816In.ucP1  = 0x00;
	Iso7816In.ucP2  = TranType;
	Iso7816In.ucP3  = 0x02;
	
	memcpy(&Iso7816In.aucDataIn[0],pucInData,Iso7816In.ucP3);
	Iso7816In.aucDataIn[Iso7816In.ucP3] = 0x08;
	
	MIFARE_SetIso7816Out();
	if( (ucResult = MIFARE_ISO(
						(unsigned char *)&Iso7816In,
						Iso7816Out.aucData,
						&Iso7816Out.uiLen,
						MIFARE_TYPE4)) != OK)
		return(ucResult);
    return(MIFARE_ISOCheckReturn());
}

unsigned char MIFARE_ISOInitForLoad(unsigned char *pucInData)
{
	unsigned char	ucResult;

	Iso7816In.ucCla = 0x80;
	Iso7816In.ucIns = 0x50;
	Iso7816In.ucP1 = 0x00;
	Iso7816In.ucP2 = 0x02;				/* 0x01 ED 0x02 EP */
	Iso7816In.ucP3  = 0x0B;

	memset(Iso7816In.aucDataIn,0,128);
	memcpy(&Iso7816In.aucDataIn[0],pucInData,Iso7816In.ucP3);
	Iso7816In.aucDataIn[Iso7816In.ucP3] = 0x10;
	MIFARE_SetIso7816Out();
	if( (ucResult = MIFARE_ISO(
						(unsigned char *)&Iso7816In,
						Iso7816Out.aucData,
						&Iso7816Out.uiLen,
						MIFARE_TYPE4)) != OK)
		return(ucResult);
	return(MIFARE_ISOCheckReturn());
}

unsigned char MIFARE_ISOLoad(unsigned char *pucDebitData,unsigned char ucLen)
{
	unsigned char	ucResult;

	Iso7816In.ucCla = 0x80;
	Iso7816In.ucIns = 0x52;
	Iso7816In.ucP1  = 0x00;
	Iso7816In.ucP2  = 0x00;
	Iso7816In.ucP3  = ucLen;
	
	memcpy(&Iso7816In.aucDataIn[0],pucDebitData,Iso7816In.ucP3);
	Iso7816In.aucDataIn[Iso7816In.ucP3] = 0x08;

	MIFARE_SetIso7816Out();
	if( (ucResult = MIFARE_ISO(
						(unsigned char *)&Iso7816In,
				path, __statbuf);
}
#  endif

__extern_inline int
__NTH (fstat64 (int __fd, struct stat64 *__statbuf))
{
  return __fxstat64 (_STAT_VER, __fd, __statbuf);
}

#  ifdef __USE_ATFILE
__extern_inline int
__NTH (fstatat64 (int __fd, __const char *__filename, struct stat64 *__statbuf,
		  int __flag))
{
  return __fxstatat64 (_STAT_VER, __fd, __filename, __statbuf, __flag);
}
#  endif

# endif

#endif

__END_DECLS


#endif /* sys/stat.h  */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   